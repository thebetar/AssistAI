(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) s(r); new MutationObserver(r => { for (const i of r) if (i.type === "childList") for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && s(o) }).observe(document, { childList: !0, subtree: !0 }); function t(r) { const i = {}; return r.integrity && (i.integrity = r.integrity), r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? i.credentials = "include" : r.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function s(r) { if (r.ep) return; r.ep = !0; const i = t(r); fetch(r.href, i) } })(); const mn = !1, bn = (n, e) => n === e, Be = Symbol("solid-proxy"), Bt = typeof Proxy == "function", wn = Symbol("solid-track"), Fe = { equals: bn }; let Ft = Gt; const pe = 1, De = 2, Dt = { owned: null, cleanups: null, context: null, owner: null }; var _ = null; let Xe = null, xn = null, z = null, G = null, ce = null, Ze = 0; function _e(n, e) { const t = z, s = _, r = n.length === 0, i = e === void 0 ? s : e, o = r ? Dt : { owned: null, cleanups: null, context: i ? i.context : null, owner: i }, l = r ? n : () => n(() => J(() => Le(o))); _ = o, z = null; try { return ge(l, !0) } finally { z = t, _ = s } } function S(n, e) { e = e ? Object.assign({}, Fe, e) : Fe; const t = { value: n, observers: null, observerSlots: null, comparator: e.equals || void 0 }, s = r => (typeof r == "function" && (r = r(t.value)), Zt(t, r)); return [Ht.bind(t), s] } function I(n, e, t) { const s = ft(n, e, !1, pe); Te(s) } function Mt(n, e, t) { Ft = Sn; const s = ft(n, e, !1, pe); s.user = !0, ce ? ce.push(s) : Te(s) } function x(n, e, t) { t = t ? Object.assign({}, Fe, t) : Fe; const s = ft(n, e, !0, 0); return s.observers = null, s.observerSlots = null, s.comparator = t.equals || void 0, Te(s), Ht.bind(s) } function kn(n) { return ge(n, !1) } function J(n) { if (z === null) return n(); const e = z; z = null; try { return n() } finally { z = e } } function at(n, e, t) { const s = Array.isArray(n); let r, i = t && t.defer; return o => { let l; if (s) { l = Array(n.length); for (let c = 0; c < n.length; c++)l[c] = n[c]() } else l = n(); if (i) return i = !1, o; const a = J(() => e(l, r, o)); return r = l, a } } function Ge(n) { Mt(() => J(n)) } function We(n) { return _ === null || (_.cleanups === null ? _.cleanups = [n] : _.cleanups.push(n)), n } function jt() { return _ } function qt(n, e) { const t = _, s = z; _ = n, z = null; try { return ge(e, !0) } catch (r) { ht(r) } finally { _ = t, z = s } } function yn(n) { const e = z, t = _; return Promise.resolve().then(() => { z = e, _ = t; let s; return ge(n, !1), z = _ = null, s ? s.done : void 0 }) } const [Yr, Xr] = S(!1); function Ut(n, e) { const t = Symbol("context"); return { id: t, Provider: An(t), defaultValue: n } } function ct(n) { let e; return _ && _.context && (e = _.context[n.id]) !== void 0 ? e : n.defaultValue } function ut(n) { const e = x(n), t = x(() => nt(e())); return t.toArray = () => { const s = t(); return Array.isArray(s) ? s : s != null ? [s] : [] }, t } function Ht() { if (this.sources && this.state) if (this.state === pe) Te(this); else { const n = G; G = null, ge(() => je(this), !1), G = n } if (z) { const n = this.observers ? this.observers.length : 0; z.sources ? (z.sources.push(this), z.sourceSlots.push(n)) : (z.sources = [this], z.sourceSlots = [n]), this.observers ? (this.observers.push(z), this.observerSlots.push(z.sources.length - 1)) : (this.observers = [z], this.observerSlots = [z.sources.length - 1]) } return this.value } function Zt(n, e, t) { let s = n.value; return (!n.comparator || !n.comparator(s, e)) && (n.value = e, n.observers && n.observers.length && ge(() => { for (let r = 0; r < n.observers.length; r += 1) { const i = n.observers[r], o = Xe && Xe.running; o && Xe.disposed.has(i), (o ? !i.tState : !i.state) && (i.pure ? G.push(i) : ce.push(i), i.observers && Wt(i)), o || (i.state = pe) } if (G.length > 1e6) throw G = [], new Error }, !1)), e } function Te(n) { if (!n.fn) return; Le(n); const e = Ze; vn(n, n.value, e) } function vn(n, e, t) { let s; const r = _, i = z; z = _ = n; try { s = n.fn(e) } catch (o) { return n.pure && (n.state = pe, n.owned && n.owned.forEach(Le), n.owned = null), n.updatedAt = t + 1, ht(o) } finally { z = i, _ = r } (!n.updatedAt || n.updatedAt <= t) && (n.updatedAt != null && "observers" in n ? Zt(n, s) : n.value = s, n.updatedAt = t) } function ft(n, e, t, s = pe, r) { const i = { fn: n, state: s, updatedAt: null, owned: null, sources: null, sourceSlots: null, cleanups: null, value: e, owner: _, context: _ ? _.context : null, pure: t }; return _ === null || _ !== Dt && (_.owned ? _.owned.push(i) : _.owned = [i]), i } function Me(n) { if (n.state === 0) return; if (n.state === De) return je(n); if (n.suspense && J(n.suspense.inFallback)) return n.suspense.effects.push(n); const e = [n]; for (; (n = n.owner) && (!n.updatedAt || n.updatedAt < Ze);)n.state && e.push(n); for (let t = e.length - 1; t >= 0; t--)if (n = e[t], n.state === pe) Te(n); else if (n.state === De) { const s = G; G = null, ge(() => je(n, e[0]), !1), G = s } } function ge(n, e) { if (G) return n(); let t = !1; e || (G = []), ce ? t = !0 : ce = [], Ze++; try { const s = n(); return $n(t), s } catch (s) { t || (ce = null), G = null, ht(s) } } function $n(n) { if (G && (Gt(G), G = null), n) return; const e = ce; ce = null, e.length && ge(() => Ft(e), !1) } function Gt(n) { for (let e = 0; e < n.length; e++)Me(n[e]) } function Sn(n) { let e, t = 0; for (e = 0; e < n.length; e++) { const s = n[e]; s.user ? n[t++] = s : Me(s) } for (e = 0; e < t; e++)Me(n[e]) } function je(n, e) { n.state = 0; for (let t = 0; t < n.sources.length; t += 1) { const s = n.sources[t]; if (s.sources) { const r = s.state; r === pe ? s !== e && (!s.updatedAt || s.updatedAt < Ze) && Me(s) : r === De && je(s, e) } } } function Wt(n) { for (let e = 0; e < n.observers.length; e += 1) { const t = n.observers[e]; t.state || (t.state = De, t.pure ? G.push(t) : ce.push(t), t.observers && Wt(t)) } } function Le(n) { let e; if (n.sources) for (; n.sources.length;) { const t = n.sources.pop(), s = n.sourceSlots.pop(), r = t.observers; if (r && r.length) { const i = r.pop(), o = t.observerSlots.pop(); s < r.length && (i.sourceSlots[o] = s, r[s] = i, t.observerSlots[s] = o) } } if (n.tOwned) { for (e = n.tOwned.length - 1; e >= 0; e--)Le(n.tOwned[e]); delete n.tOwned } if (n.owned) { for (e = n.owned.length - 1; e >= 0; e--)Le(n.owned[e]); n.owned = null } if (n.cleanups) { for (e = n.cleanups.length - 1; e >= 0; e--)n.cleanups[e](); n.cleanups = null } n.state = 0 } function _n(n) { return n instanceof Error ? n : new Error(typeof n == "string" ? n : "Unknown error", { cause: n }) } function ht(n, e = _) { throw _n(n) } function nt(n) { if (typeof n == "function" && !n.length) return nt(n()); if (Array.isArray(n)) { const e = []; for (let t = 0; t < n.length; t++) { const s = nt(n[t]); Array.isArray(s) ? e.push.apply(e, s) : e.push(s) } return e } return n } function An(n, e) { return function (s) { let r; return I(() => r = J(() => (_.context = { ..._.context, [n]: s.value }, ut(() => s.children))), void 0), r } } const Cn = Symbol("fallback"); function At(n) { for (let e = 0; e < n.length; e++)n[e]() } function Ln(n, e, t = {}) { let s = [], r = [], i = [], o = 0, l = e.length > 1 ? [] : null; return We(() => At(i)), () => { let a = n() || [], c = a.length, f, u; return a[wn], J(() => { let p, m, h, g, k, b, P, R, N; if (c === 0) o !== 0 && (At(i), i = [], s = [], r = [], o = 0, l && (l = [])), t.fallback && (s = [Cn], r[0] = _e(H => (i[0] = H, t.fallback())), o = 1); else if (o === 0) { for (r = new Array(c), u = 0; u < c; u++)s[u] = a[u], r[u] = _e(d); o = c } else { for (h = new Array(c), g = new Array(c), l && (k = new Array(c)), b = 0, P = Math.min(o, c); b < P && s[b] === a[b]; b++); for (P = o - 1, R = c - 1; P >= b && R >= b && s[P] === a[R]; P--, R--)h[R] = r[P], g[R] = i[P], l && (k[R] = l[P]); for (p = new Map, m = new Array(R + 1), u = R; u >= b; u--)N = a[u], f = p.get(N), m[u] = f === void 0 ? -1 : f, p.set(N, u); for (f = b; f <= P; f++)N = s[f], u = p.get(N), u !== void 0 && u !== -1 ? (h[u] = r[f], g[u] = i[f], l && (k[u] = l[f]), u = m[u], p.set(N, u)) : i[f](); for (u = b; u < c; u++)u in h ? (r[u] = h[u], i[u] = g[u], l && (l[u] = k[u], l[u](u))) : r[u] = _e(d); r = r.slice(0, o = c), s = a.slice(0) } return r }); function d(p) { if (i[u] = p, l) { const [m, h] = S(u); return l[u] = h, e(a[u], m) } return e(a[u]) } } } function D(n, e) { return J(() => n(e || {})) } function ze() { return !0 } const st = { get(n, e, t) { return e === Be ? t : n.get(e) }, has(n, e) { return e === Be ? !0 : n.has(e) }, set: ze, deleteProperty: ze, getOwnPropertyDescriptor(n, e) { return { configurable: !0, enumerable: !0, get() { return n.get(e) }, set: ze, deleteProperty: ze } }, ownKeys(n) { return n.keys() } }; function Je(n) { return (n = typeof n == "function" ? n() : n) ? n : {} } function Rn() { for (let n = 0, e = this.length; n < e; ++n) { const t = this[n](); if (t !== void 0) return t } } function rt(...n) { let e = !1; for (let o = 0; o < n.length; o++) { const l = n[o]; e = e || !!l && Be in l, n[o] = typeof l == "function" ? (e = !0, x(l)) : l } if (Bt && e) return new Proxy({ get(o) { for (let l = n.length - 1; l >= 0; l--) { const a = Je(n[l])[o]; if (a !== void 0) return a } }, has(o) { for (let l = n.length - 1; l >= 0; l--)if (o in Je(n[l])) return !0; return !1 }, keys() { const o = []; for (let l = 0; l < n.length; l++)o.push(...Object.keys(Je(n[l]))); return [...new Set(o)] } }, st); const t = {}, s = Object.create(null); for (let o = n.length - 1; o >= 0; o--) { const l = n[o]; if (!l) continue; const a = Object.getOwnPropertyNames(l); for (let c = a.length - 1; c >= 0; c--) { const f = a[c]; if (f === "__proto__" || f === "constructor") continue; const u = Object.getOwnPropertyDescriptor(l, f); if (!s[f]) s[f] = u.get ? { enumerable: !0, configurable: !0, get: Rn.bind(t[f] = [u.get.bind(l)]) } : u.value !== void 0 ? u : void 0; else { const d = t[f]; d && (u.get ? d.push(u.get.bind(l)) : u.value !== void 0 && d.push(() => u.value)) } } } const r = {}, i = Object.keys(s); for (let o = i.length - 1; o >= 0; o--) { const l = i[o], a = s[l]; a && a.get ? Object.defineProperty(r, l, a) : r[l] = a ? a.value : void 0 } return r } function Tn(n, ...e) { if (Bt && Be in n) { const r = new Set(e.length > 1 ? e.flat() : e[0]), i = e.map(o => new Proxy({ get(l) { return o.includes(l) ? n[l] : void 0 }, has(l) { return o.includes(l) && l in n }, keys() { return o.filter(l => l in n) } }, st)); return i.push(new Proxy({ get(o) { return r.has(o) ? void 0 : n[o] }, has(o) { return r.has(o) ? !1 : o in n }, keys() { return Object.keys(n).filter(o => !r.has(o)) } }, st)), i } const t = {}, s = e.map(() => ({})); for (const r of Object.getOwnPropertyNames(n)) { const i = Object.getOwnPropertyDescriptor(n, r), o = !i.get && !i.set && i.enumerable && i.writable && i.configurable; let l = !1, a = 0; for (const c of e) c.includes(r) && (l = !0, o ? s[a][r] = i.value : Object.defineProperty(s[a], r, i)), ++a; l || (o ? t[r] = i.value : Object.defineProperty(t, r, i)) } return [...s, t] } const Pn = n => `Stale read from <${n}>.`; function zn(n) { const e = "fallback" in n && { fallback: () => n.fallback }; return x(Ln(() => n.each, n.children, e || void 0)) } function Kt(n) { const e = n.keyed, t = x(() => n.when, void 0, void 0), s = e ? t : x(t, void 0, { equals: (r, i) => !r == !i }); return x(() => { const r = s(); if (r) { const i = n.children; return typeof i == "function" && i.length > 0 ? J(() => i(e ? r : () => { if (!J(s)) throw Pn("Show"); return t() })) : i } return n.fallback }, void 0, void 0) } const En = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"], In = new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...En]), On = new Set(["innerHTML", "textContent", "innerText", "children"]), Nn = Object.assign(Object.create(null), { className: "class", htmlFor: "for" }), Bn = Object.assign(Object.create(null), { class: "className", formnovalidate: { $: "formNoValidate", BUTTON: 1, INPUT: 1 }, ismap: { $: "isMap", IMG: 1 }, nomodule: { $: "noModule", SCRIPT: 1 }, playsinline: { $: "playsInline", VIDEO: 1 }, readonly: { $: "readOnly", INPUT: 1, TEXTAREA: 1 } }); function Fn(n, e) { const t = Bn[n]; return typeof t == "object" ? t[e] ? t.$ : void 0 : t } const Dn = new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]); function Mn(n, e, t) { let s = t.length, r = e.length, i = s, o = 0, l = 0, a = e[r - 1].nextSibling, c = null; for (; o < r || l < i;) { if (e[o] === t[l]) { o++, l++; continue } for (; e[r - 1] === t[i - 1];)r--, i--; if (r === o) { const f = i < s ? l ? t[l - 1].nextSibling : t[i - l] : a; for (; l < i;)n.insertBefore(t[l++], f) } else if (i === l) for (; o < r;)(!c || !c.has(e[o])) && e[o].remove(), o++; else if (e[o] === t[i - 1] && t[l] === e[r - 1]) { const f = e[--r].nextSibling; n.insertBefore(t[l++], e[o++].nextSibling), n.insertBefore(t[--i], f), e[r] = t[i] } else { if (!c) { c = new Map; let u = l; for (; u < i;)c.set(t[u], u++) } const f = c.get(e[o]); if (f != null) if (l < f && f < i) { let u = o, d = 1, p; for (; ++u < r && u < i && !((p = c.get(e[u])) == null || p !== f + d);)d++; if (d > f - l) { const m = e[o]; for (; l < f;)n.insertBefore(t[l++], m) } else n.replaceChild(t[l++], e[o++]) } else o++; else e[o++].remove() } } } const Ct = "_$DX_DELEGATE"; function jn(n, e, t, s = {}) { let r; return _e(i => { r = i, e === document ? n() : E(e, n(), e.firstChild ? null : void 0, t) }, s.owner), () => { r(), e.textContent = "" } } function T(n, e, t, s) { let r; const i = () => { const l = document.createElement("template"); return l.innerHTML = n, l.content.firstChild }, o = () => (r || (r = i())).cloneNode(!0); return o.cloneNode = o, o } function ye(n, e = window.document) { const t = e[Ct] || (e[Ct] = new Set); for (let s = 0, r = n.length; s < r; s++) { const i = n[s]; t.has(i) || (t.add(i), e.addEventListener(i, Qn)) } } function de(n, e, t) { t == null ? n.removeAttribute(e) : n.setAttribute(e, t) } function qn(n, e, t) { t ? n.setAttribute(e, "") : n.removeAttribute(e) } function Ke(n, e) { e == null ? n.removeAttribute("class") : n.className = e } function Un(n, e, t, s) { if (s) Array.isArray(t) ? (n[`$$${e}`] = t[0], n[`$$${e}Data`] = t[1]) : n[`$$${e}`] = t; else if (Array.isArray(t)) { const r = t[0]; n.addEventListener(e, t[0] = i => r.call(n, t[1], i)) } else n.addEventListener(e, t, typeof t != "function" && t) } function Hn(n, e, t = {}) { const s = Object.keys(e || {}), r = Object.keys(t); let i, o; for (i = 0, o = r.length; i < o; i++) { const l = r[i]; !l || l === "undefined" || e[l] || (Lt(n, l, !1), delete t[l]) } for (i = 0, o = s.length; i < o; i++) { const l = s[i], a = !!e[l]; !l || l === "undefined" || t[l] === a || !a || (Lt(n, l, !0), t[l] = a) } return t } function Zn(n, e, t) { if (!e) return t ? de(n, "style") : e; const s = n.style; if (typeof e == "string") return s.cssText = e; typeof t == "string" && (s.cssText = t = void 0), t || (t = {}), e || (e = {}); let r, i; for (i in t) e[i] == null && s.removeProperty(i), delete t[i]; for (i in e) r = e[i], r !== t[i] && (s.setProperty(i, r), t[i] = r); return t } function Gn(n, e = {}, t, s) { const r = {}; return I(() => r.children = Re(n, e.children, r.children)), I(() => typeof e.ref == "function" && Qt(e.ref, n)), I(() => Wn(n, e, t, !0, r, !0)), r } function Qt(n, e, t) { return J(() => n(e, t)) } function E(n, e, t, s) { if (t !== void 0 && !s && (s = []), typeof e != "function") return Re(n, e, s, t); I(r => Re(n, e(), r, t), s) } function Wn(n, e, t, s, r = {}, i = !1) { e || (e = {}); for (const o in r) if (!(o in e)) { if (o === "children") continue; r[o] = Rt(n, o, null, r[o], t, i, e) } for (const o in e) { if (o === "children") continue; const l = e[o]; r[o] = Rt(n, o, l, r[o], t, i, e) } } function Kn(n) { return n.toLowerCase().replace(/-([a-z])/g, (e, t) => t.toUpperCase()) } function Lt(n, e, t) { const s = e.trim().split(/\s+/); for (let r = 0, i = s.length; r < i; r++)n.classList.toggle(s[r], t) } function Rt(n, e, t, s, r, i, o) { let l, a, c, f, u; if (e === "style") return Zn(n, t, s); if (e === "classList") return Hn(n, t, s); if (t === s) return s; if (e === "ref") i || t(n); else if (e.slice(0, 3) === "on:") { const d = e.slice(3); s && n.removeEventListener(d, s, typeof s != "function" && s), t && n.addEventListener(d, t, typeof t != "function" && t) } else if (e.slice(0, 10) === "oncapture:") { const d = e.slice(10); s && n.removeEventListener(d, s, !0), t && n.addEventListener(d, t, !0) } else if (e.slice(0, 2) === "on") { const d = e.slice(2).toLowerCase(), p = Dn.has(d); if (!p && s) { const m = Array.isArray(s) ? s[0] : s; n.removeEventListener(d, m) } (p || t) && (Un(n, d, t, p), p && ye([d])) } else e.slice(0, 5) === "attr:" ? de(n, e.slice(5), t) : e.slice(0, 5) === "bool:" ? qn(n, e.slice(5), t) : (u = e.slice(0, 5) === "prop:") || (c = On.has(e)) || (f = Fn(e, n.tagName)) || (a = In.has(e)) || (l = n.nodeName.includes("-") || "is" in o) ? (u && (e = e.slice(5), a = !0), e === "class" || e === "className" ? Ke(n, t) : l && !a && !c ? n[Kn(e)] = t : n[f || e] = t) : de(n, Nn[e] || e, t); return t } function Qn(n) { let e = n.target; const t = `$$${n.type}`, s = n.target, r = n.currentTarget, i = a => Object.defineProperty(n, "target", { configurable: !0, value: a }), o = () => { const a = e[t]; if (a && !e.disabled) { const c = e[`${t}Data`]; if (c !== void 0 ? a.call(e, c, n) : a.call(e, n), n.cancelBubble) return } return e.host && typeof e.host != "string" && !e.host._$host && e.contains(n.target) && i(e.host), !0 }, l = () => { for (; o() && (e = e._$host || e.parentNode || e.host);); }; if (Object.defineProperty(n, "currentTarget", { configurable: !0, get() { return e || document } }), n.composedPath) { const a = n.composedPath(); i(a[0]); for (let c = 0; c < a.length - 2 && (e = a[c], !!o()); c++) { if (e._$host) { e = e._$host, l(); break } if (e.parentNode === r) break } } else l(); i(s) } function Re(n, e, t, s, r) { for (; typeof t == "function";)t = t(); if (e === t) return t; const i = typeof e, o = s !== void 0; if (n = o && t[0] && t[0].parentNode || n, i === "string" || i === "number") { if (i === "number" && (e = e.toString(), e === t)) return t; if (o) { let l = t[0]; l && l.nodeType === 3 ? l.data !== e && (l.data = e) : l = document.createTextNode(e), t = ke(n, t, s, l) } else t !== "" && typeof t == "string" ? t = n.firstChild.data = e : t = n.textContent = e } else if (e == null || i === "boolean") t = ke(n, t, s); else { if (i === "function") return I(() => { let l = e(); for (; typeof l == "function";)l = l(); t = Re(n, l, t, s) }), () => t; if (Array.isArray(e)) { const l = [], a = t && Array.isArray(t); if (it(l, e, t, r)) return I(() => t = Re(n, l, t, s, !0)), () => t; if (l.length === 0) { if (t = ke(n, t, s), o) return t } else a ? t.length === 0 ? Tt(n, l, s) : Mn(n, t, l) : (t && ke(n), Tt(n, l)); t = l } else if (e.nodeType) { if (Array.isArray(t)) { if (o) return t = ke(n, t, s, e); ke(n, t, null, e) } else t == null || t === "" || !n.firstChild ? n.appendChild(e) : n.replaceChild(e, n.firstChild); t = e } } return t } function it(n, e, t, s) { let r = !1; for (let i = 0, o = e.length; i < o; i++) { let l = e[i], a = t && t[n.length], c; if (!(l == null || l === !0 || l === !1)) if ((c = typeof l) == "object" && l.nodeType) n.push(l); else if (Array.isArray(l)) r = it(n, l, a) || r; else if (c === "function") if (s) { for (; typeof l == "function";)l = l(); r = it(n, Array.isArray(l) ? l : [l], Array.isArray(a) ? a : [a]) || r } else n.push(l), r = !0; else { const f = String(l); a && a.nodeType === 3 && a.data === f ? n.push(a) : n.push(document.createTextNode(f)) } } return r } function Tt(n, e, t = null) { for (let s = 0, r = e.length; s < r; s++)n.insertBefore(e[s], t) } function ke(n, e, t, s) { if (t === void 0) return n.textContent = ""; const r = s || document.createTextNode(""); if (e.length) { let i = !1; for (let o = e.length - 1; o >= 0; o--) { const l = e[o]; if (r !== l) { const a = l.parentNode === n; !i && !o ? a ? n.replaceChild(r, l) : n.insertBefore(r, t) : a && l.remove() } else i = !0 } } else n.insertBefore(r, t); return [r] } const Vn = !1; function Vt() { let n = new Set; function e(r) { return n.add(r), () => n.delete(r) } let t = !1; function s(r, i) { if (t) return !(t = !1); const o = { to: r, options: i, defaultPrevented: !1, preventDefault: () => o.defaultPrevented = !0 }; for (const l of n) l.listener({ ...o, from: l.location, retry: a => { a && (t = !0), l.navigate(r, { ...i, resolve: !1 }) } }); return !o.defaultPrevented } return { subscribe: e, confirm: s } } let ot; function dt() { (!window.history.state || window.history.state._depth == null) && window.history.replaceState({ ...window.history.state, _depth: window.history.length - 1 }, ""), ot = window.history.state._depth } dt(); function Yn(n) { return { ...n, _depth: window.history.state && window.history.state._depth } } function Xn(n, e) { let t = !1; return () => { const s = ot; dt(); const r = s == null ? null : ot - s; if (t) { t = !1; return } r && e(r) ? (t = !0, window.history.go(-r)) : n() } } const Jn = /^(?:[a-z0-9]+:)?\/\//i, es = /^\/+|(\/)\/+$/g, Yt = "http://sr"; function be(n, e = !1) { const t = n.replace(es, "$1"); return t ? e || /^[?#]/.test(t) ? t : "/" + t : "" } function Oe(n, e, t) { if (Jn.test(e)) return; const s = be(n), r = t && be(t); let i = ""; return !r || e.startsWith("/") ? i = s : r.toLowerCase().indexOf(s.toLowerCase()) !== 0 ? i = s + r : i = r, (i || "/") + be(e, !i) } function ts(n, e) { if (n == null) throw new Error(e); return n } function ns(n, e) { return be(n).replace(/\/*(\*.*)?$/g, "") + be(e) } function Xt(n) { const e = {}; return n.searchParams.forEach((t, s) => { s in e ? Array.isArray(e[s]) ? e[s].push(t) : e[s] = [e[s], t] : e[s] = t }), e } function ss(n, e, t) { const [s, r] = n.split("/*", 2), i = s.split("/").filter(Boolean), o = i.length; return l => { const a = l.split("/").filter(Boolean), c = a.length - o; if (c < 0 || c > 0 && r === void 0 && !e) return null; const f = { path: o ? "" : "/", params: {} }, u = d => t === void 0 ? void 0 : t[d]; for (let d = 0; d < o; d++) { const p = i[d], m = p[0] === ":", h = m ? a[d] : a[d].toLowerCase(), g = m ? p.slice(1) : p.toLowerCase(); if (m && et(h, u(g))) f.params[g] = h; else if (m || !et(h, g)) return null; f.path += `/${h}` } if (r) { const d = c ? a.slice(-c).join("/") : ""; if (et(d, u(r))) f.params[r] = d; else return null } return f } } function et(n, e) { const t = s => s === n; return e === void 0 ? !0 : typeof e == "string" ? t(e) : typeof e == "function" ? e(n) : Array.isArray(e) ? e.some(t) : e instanceof RegExp ? e.test(n) : !1 } function rs(n) { const [e, t] = n.pattern.split("/*", 2), s = e.split("/").filter(Boolean); return s.reduce((r, i) => r + (i.startsWith(":") ? 2 : 3), s.length - (t === void 0 ? 0 : 1)) } function Jt(n) { const e = new Map, t = jt(); return new Proxy({}, { get(s, r) { return e.has(r) || qt(t, () => e.set(r, x(() => n()[r]))), e.get(r)() }, getOwnPropertyDescriptor() { return { enumerable: !0, configurable: !0 } }, ownKeys() { return Reflect.ownKeys(n()) } }) } function en(n) { let e = /(\/?\:[^\/]+)\?/.exec(n); if (!e) return [n]; let t = n.slice(0, e.index), s = n.slice(e.index + e[0].length); const r = [t, t += e[1]]; for (; e = /^(\/\:[^\/]+)\?/.exec(s);)r.push(t += e[1]), s = s.slice(e[0].length); return en(s).reduce((i, o) => [...i, ...r.map(l => l + o)], []) } const is = 100, tn = Ut(), pt = Ut(), Qe = () => ts(ct(tn), "<A> and 'use' router primitives can be only used inside a Route."), os = () => ct(pt) || Qe().base, ls = n => { const e = os(); return x(() => e.resolvePath(n())) }, as = n => { const e = Qe(); return x(() => { const t = n(); return t !== void 0 ? e.renderPath(t) : t }) }, cs = () => Qe().navigatorFactory(), us = () => Qe().location; function fs(n, e = "") { const { component: t, preload: s, load: r, children: i, info: o } = n, l = !i || Array.isArray(i) && !i.length, a = { key: n, component: t, preload: s || r, info: o }; return nn(n.path).reduce((c, f) => { for (const u of en(f)) { const d = ns(e, u); let p = l ? d : d.split("/*", 1)[0]; p = p.split("/").map(m => m.startsWith(":") || m.startsWith("*") ? m : encodeURIComponent(m)).join("/"), c.push({ ...a, originalPath: f, pattern: p, matcher: ss(p, !l, n.matchFilters) }) } return c }, []) } function hs(n, e = 0) { return { routes: n, score: rs(n[n.length - 1]) * 1e4 - e, matcher(t) { const s = []; for (let r = n.length - 1; r >= 0; r--) { const i = n[r], o = i.matcher(t); if (!o) return null; s.unshift({ ...o, route: i }) } return s } } } function nn(n) { return Array.isArray(n) ? n : [n] } function sn(n, e = "", t = [], s = []) { const r = nn(n); for (let i = 0, o = r.length; i < o; i++) { const l = r[i]; if (l && typeof l == "object") { l.hasOwnProperty("path") || (l.path = ""); const a = fs(l, e); for (const c of a) { t.push(c); const f = Array.isArray(l.children) && l.children.length === 0; if (l.children && !f) sn(l.children, c.pattern, t, s); else { const u = hs([...t], s.length); s.push(u) } t.pop() } } } return t.length ? s : s.sort((i, o) => o.score - i.score) } function tt(n, e) { for (let t = 0, s = n.length; t < s; t++) { const r = n[t].matcher(e); if (r) return r } return [] } function ds(n, e, t) { const s = new URL(Yt), r = x(f => { const u = n(); try { return new URL(u, s) } catch { return console.error(`Invalid path ${u}`), f } }, s, { equals: (f, u) => f.href === u.href }), i = x(() => r().pathname), o = x(() => r().search, !0), l = x(() => r().hash), a = () => "", c = at(o, () => Xt(r())); return { get pathname() { return i() }, get search() { return o() }, get hash() { return l() }, get state() { return e() }, get key() { return a() }, query: t ? t(c) : Jt(c) } } let me; function ps() { return me } function gs(n, e, t, s = {}) { const { signal: [r, i], utils: o = {} } = n, l = o.parsePath || (y => y), a = o.renderPath || (y => y), c = o.beforeLeave || Vt(), f = Oe("", s.base || ""); if (f === void 0) throw new Error(`${f} is not a valid base path`); f && !r().value && i({ value: f, replace: !0, scroll: !1 }); const [u, d] = S(!1); let p; const m = (y, $) => { $.value === h() && $.state === k() || (p === void 0 && d(!0), me = y, p = $, yn(() => { p === $ && (g(p.value), b(p.state), N[1](w => w.filter(O => O.pending))) }).finally(() => { p === $ && kn(() => { me = void 0, y === "navigate" && Z(p), d(!1), p = void 0 }) })) }, [h, g] = S(r().value), [k, b] = S(r().state), P = ds(h, k, o.queryWrapper), R = [], N = S([]), H = x(() => typeof s.transformUrl == "function" ? tt(e(), s.transformUrl(P.pathname)) : tt(e(), P.pathname)), ee = () => { const y = H(), $ = {}; for (let w = 0; w < y.length; w++)Object.assign($, y[w].params); return $ }, te = o.paramsWrapper ? o.paramsWrapper(ee, e) : Jt(ee), v = { pattern: f, path: () => f, outlet: () => null, resolvePath(y) { return Oe(f, y) } }; return I(at(r, y => m("native", y), { defer: !0 })), { base: v, location: P, params: te, isRouting: u, renderPath: a, parsePath: l, navigatorFactory: V, matches: H, beforeLeave: c, preloadRoute: se, singleFlight: s.singleFlight === void 0 ? !0 : s.singleFlight, submissions: N }; function B(y, $, w) { J(() => { if (typeof $ == "number") { $ && (o.go ? o.go($) : console.warn("Router integration does not support relative routing")); return } const O = !$ || $[0] === "?", { replace: j, resolve: M, scroll: re, state: le } = { replace: !1, resolve: !O, scroll: !0, ...w }, C = M ? y.resolvePath($) : Oe(O && P.pathname || "", $); if (C === void 0) throw new Error(`Path '${$}' is not a routable path`); if (R.length >= is) throw new Error("Too many redirects"); const q = h(); (C !== q || le !== k()) && (Vn || c.confirm(C, w) && (R.push({ value: q, replace: j, scroll: re, state: k() }), m("navigate", { value: C, state: le }))) }) } function V(y) { return y = y || ct(pt) || v, ($, w) => B(y, $, w) } function Z(y) { const $ = R[0]; $ && (i({ ...y, replace: $.replace, scroll: $.scroll }), R.length = 0) } function se(y, $) { const w = tt(e(), y.pathname), O = me; me = "preload"; for (let j in w) { const { route: M, params: re } = w[j]; M.component && M.component.preload && M.component.preload(); const { preload: le } = M; $ && le && qt(t(), () => le({ params: re, location: { pathname: y.pathname, search: y.search, hash: y.hash, query: Xt(y), state: null, key: "" }, intent: "preload" })) } me = O } } function ms(n, e, t, s) { const { base: r, location: i, params: o } = n, { pattern: l, component: a, preload: c } = s().route, f = x(() => s().path); a && a.preload && a.preload(); const u = c ? c({ params: o, location: i, intent: me || "initial" }) : void 0; return { parent: e, pattern: l, path: f, outlet: () => a ? D(a, { params: o, location: i, data: u, get children() { return t() } }) : t(), resolvePath(p) { return Oe(r.path(), p, f()) } } } const bs = n => e => { const { base: t } = e, s = ut(() => e.children), r = x(() => sn(s(), e.base || "")); let i; const o = gs(n, r, () => i, { base: t, singleFlight: e.singleFlight, transformUrl: e.transformUrl }); return n.create && n.create(o), D(tn.Provider, { value: o, get children() { return D(ws, { routerState: o, get root() { return e.root }, get preload() { return e.rootPreload || e.rootLoad }, get children() { return [x(() => (i = jt()) && null), D(xs, { routerState: o, get branches() { return r() } })] } }) } }) }; function ws(n) { const e = n.routerState.location, t = n.routerState.params, s = x(() => n.preload && J(() => { n.preload({ params: t, location: e, intent: ps() || "initial" }) })); return D(Kt, { get when() { return n.root }, keyed: !0, get fallback() { return n.children }, children: r => D(r, { params: t, location: e, get data() { return s() }, get children() { return n.children } }) }) } function xs(n) { const e = []; let t; const s = x(at(n.routerState.matches, (r, i, o) => { let l = i && r.length === i.length; const a = []; for (let c = 0, f = r.length; c < f; c++) { const u = i && i[c], d = r[c]; o && u && d.route.key === u.route.key ? a[c] = o[c] : (l = !1, e[c] && e[c](), _e(p => { e[c] = p, a[c] = ms(n.routerState, a[c - 1] || n.routerState.base, Pt(() => s()[c + 1]), () => n.routerState.matches()[c]) })) } return e.splice(r.length).forEach(c => c()), o && l ? o : (t = a[0], a) })); return Pt(() => s() && t)() } const Pt = n => () => D(Kt, { get when() { return n() }, keyed: !0, children: e => D(pt.Provider, { value: e, get children() { return e.outlet() } }) }), Ee = n => { const e = ut(() => n.children); return rt(n, { get children() { return e() } }) }; function ks([n, e], t, s) { return [n, s ? r => e(s(r)) : e] } function ys(n) { let e = !1; const t = r => typeof r == "string" ? { value: r } : r, s = ks(S(t(n.get()), { equals: (r, i) => r.value === i.value && r.state === i.state }), void 0, r => (!e && n.set(r), r)); return n.init && We(n.init((r = n.get()) => { e = !0, s[1](t(r)), e = !1 })), bs({ signal: s, create: n.create, utils: n.utils }) } function vs(n, e, t) { return n.addEventListener(e, t), () => n.removeEventListener(e, t) } function $s(n, e) { const t = n && document.getElementById(n); t ? t.scrollIntoView() : e && window.scrollTo(0, 0) } const Ss = new Map; function _s(n = !0, e = !1, t = "/_server", s) { return r => { const i = r.base.path(), o = r.navigatorFactory(r.base); let l, a; function c(h) { return h.namespaceURI === "http://www.w3.org/2000/svg" } function f(h) { if (h.defaultPrevented || h.button !== 0 || h.metaKey || h.altKey || h.ctrlKey || h.shiftKey) return; const g = h.composedPath().find(H => H instanceof Node && H.nodeName.toUpperCase() === "A"); if (!g || e && !g.hasAttribute("link")) return; const k = c(g), b = k ? g.href.baseVal : g.href; if ((k ? g.target.baseVal : g.target) || !b && !g.hasAttribute("state")) return; const R = (g.getAttribute("rel") || "").split(/\s+/); if (g.hasAttribute("download") || R && R.includes("external")) return; const N = k ? new URL(b, document.baseURI) : new URL(b); if (!(N.origin !== window.location.origin || i && N.pathname && !N.pathname.toLowerCase().startsWith(i.toLowerCase()))) return [g, N] } function u(h) { const g = f(h); if (!g) return; const [k, b] = g, P = r.parsePath(b.pathname + b.search + b.hash), R = k.getAttribute("state"); h.preventDefault(), o(P, { resolve: !1, replace: k.hasAttribute("replace"), scroll: !k.hasAttribute("noscroll"), state: R ? JSON.parse(R) : void 0 }) } function d(h) { const g = f(h); if (!g) return; const [k, b] = g; s && (b.pathname = s(b.pathname)), r.preloadRoute(b, k.getAttribute("preload") !== "false") } function p(h) { clearTimeout(l); const g = f(h); if (!g) return a = null; const [k, b] = g; a !== k && (s && (b.pathname = s(b.pathname)), l = setTimeout(() => { r.preloadRoute(b, k.getAttribute("preload") !== "false"), a = k }, 20)) } function m(h) { if (h.defaultPrevented) return; let g = h.submitter && h.submitter.hasAttribute("formaction") ? h.submitter.getAttribute("formaction") : h.target.getAttribute("action"); if (!g) return; if (!g.startsWith("https://action/")) { const b = new URL(g, Yt); if (g = r.parsePath(b.pathname + b.search), !g.startsWith(t)) return } if (h.target.method.toUpperCase() !== "POST") throw new Error("Only POST forms are supported for Actions"); const k = Ss.get(g); if (k) { h.preventDefault(); const b = new FormData(h.target, h.submitter); k.call({ r, f: h.target }, h.target.enctype === "multipart/form-data" ? b : new URLSearchParams(b)) } } ye(["click", "submit"]), document.addEventListener("click", u), n && (document.addEventListener("mousemove", p, { passive: !0 }), document.addEventListener("focusin", d, { passive: !0 }), document.addEventListener("touchstart", d, { passive: !0 })), document.addEventListener("submit", m), We(() => { document.removeEventListener("click", u), n && (document.removeEventListener("mousemove", p), document.removeEventListener("focusin", d), document.removeEventListener("touchstart", d)), document.removeEventListener("submit", m) }) } } function As(n) { const e = () => { const s = window.location.pathname.replace(/^\/+/, "/") + window.location.search, r = window.history.state && window.history.state._depth && Object.keys(window.history.state).length === 1 ? void 0 : window.history.state; return { value: s + window.location.hash, state: r } }, t = Vt(); return ys({ get: e, set({ value: s, replace: r, scroll: i, state: o }) { r ? window.history.replaceState(Yn(o), "", s) : window.history.pushState(o, "", s), $s(decodeURIComponent(window.location.hash.slice(1)), i), dt() }, init: s => vs(window, "popstate", Xn(s, r => { if (r && r < 0) return !t.confirm(r); { const i = e(); return !t.confirm(i.value, { state: i.state }) } })), create: _s(n.preload, n.explicitLinks, n.actionBase, n.transformUrl), utils: { go: s => window.history.go(s), beforeLeave: t } })(n) } var Cs = T("<a>"); function Ls(n) { n = rt({ inactiveClass: "inactive", activeClass: "active" }, n); const [, e] = Tn(n, ["href", "state", "class", "activeClass", "inactiveClass", "end"]), t = ls(() => n.href), s = as(t), r = us(), i = x(() => { const o = t(); if (o === void 0) return [!1, !1]; const l = be(o.split(/[?#]/, 1)[0]).toLowerCase(), a = decodeURI(be(r.pathname).toLowerCase()); return [n.end ? l === a : a.startsWith(l + "/") || a === l, l === a] }); return (() => { var o = Cs(); return Gn(o, rt(e, { get href() { return s() || n.href }, get state() { return JSON.stringify(n.state) }, get classList() { return { ...n.class && { [n.class]: !0 }, [n.inactiveClass]: !i()[0], [n.activeClass]: i()[0], ...e.classList } }, link: "", get "aria-current"() { return i()[1] ? "page" : void 0 } }), !1), o })() } const Rs = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3c!--!%20Font%20Awesome%20Free%206.7.2%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20(Icons:%20CC%20BY%204.0,%20Fonts:%20SIL%20OFL%201.1,%20Code:%20MIT%20License)%20Copyright%202024%20Fonticons,%20Inc.%20--%3e%3cpath%20fill='%23ffffff'%20d='M160%20368c26.5%200%2048%2021.5%2048%2048l0%2016%2072.5-54.4c8.3-6.2%2018.4-9.6%2028.8-9.6L448%20368c8.8%200%2016-7.2%2016-16l0-288c0-8.8-7.2-16-16-16L64%2048c-8.8%200-16%207.2-16%2016l0%20288c0%208.8%207.2%2016%2016%2016l96%200zm48%20124l-.2%20.2-5.1%203.8-17.1%2012.8c-4.8%203.6-11.3%204.2-16.8%201.5s-8.8-8.2-8.8-14.3l0-21.3%200-6.4%200-.3%200-4%200-48-48%200-48%200c-35.3%200-64-28.7-64-64L0%2064C0%2028.7%2028.7%200%2064%200L448%200c35.3%200%2064%2028.7%2064%2064l0%20288c0%2035.3-28.7%2064-64%2064l-138.7%200L208%20492z'%20/%3e%3c/svg%3e", Ts = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20448%20512'%3e%3c!--!%20Font%20Awesome%20Free%206.7.2%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20(Icons:%20CC%20BY%204.0,%20Fonts:%20SIL%20OFL%201.1,%20Code:%20MIT%20License)%20Copyright%202024%20Fonticons,%20Inc.%20--%3e%3cpath%20fill='%23ffffff'%20d='M64%2080c-8.8%200-16%207.2-16%2016l0%20320c0%208.8%207.2%2016%2016%2016l224%200%200-80c0-17.7%2014.3-32%2032-32l80%200%200-224c0-8.8-7.2-16-16-16L64%2080zM288%20480L64%20480c-35.3%200-64-28.7-64-64L0%2096C0%2060.7%2028.7%2032%2064%2032l320%200c35.3%200%2064%2028.7%2064%2064l0%20224%200%205.5c0%2017-6.7%2033.3-18.7%2045.3l-90.5%2090.5c-12%2012-28.3%2018.7-45.3%2018.7l-5.5%200z'%20/%3e%3c/svg%3e", Ps = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3c!--!%20Font%20Awesome%20Free%206.7.2%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20(Icons:%20CC%20BY%204.0,%20Fonts:%20SIL%20OFL%201.1,%20Code:%20MIT%20License)%20Copyright%202024%20Fonticons,%20Inc.%20--%3e%3cpath%20fill='%23ffffff'%20d='M266.3%2048.3L232.5%2073.6c-5.4%204-8.5%2010.4-8.5%2017.1l0%209.1c0%206.8%205.5%2012.3%2012.3%2012.3c2.4%200%204.8-.7%206.8-2.1l41.8-27.9c2-1.3%204.4-2.1%206.8-2.1l1%200c6.2%200%2011.3%205.1%2011.3%2011.3c0%203-1.2%205.9-3.3%208l-19.9%2019.9c-5.8%205.8-12.9%2010.2-20.7%2012.8l-26.5%208.8c-5.8%201.9-9.6%207.3-9.6%2013.4c0%203.7-1.5%207.3-4.1%2010l-17.9%2017.9c-6.4%206.4-9.9%2015-9.9%2024l0%204.3c0%2016.4%2013.6%2029.7%2029.9%2029.7c11%200%2021.2-6.2%2026.1-16l4-8.1c2.4-4.8%207.4-7.9%2012.8-7.9c4.5%200%208.7%202.1%2011.4%205.7l16.3%2021.7c2.1%202.9%205.5%204.5%209.1%204.5c8.4%200%2013.9-8.9%2010.1-16.4l-1.1-2.3c-3.5-7%200-15.5%207.5-18l21.2-7.1c7.6-2.5%2012.7-9.6%2012.7-17.6c0-10.3%208.3-18.6%2018.6-18.6l29.4%200c8.8%200%2016%207.2%2016%2016s-7.2%2016-16%2016l-20.7%200c-7.2%200-14.2%202.9-19.3%208l-4.7%204.7c-2.1%202.1-3.3%205-3.3%208c0%206.2%205.1%2011.3%2011.3%2011.3l11.3%200c6%200%2011.8%202.4%2016%206.6l6.5%206.5c1.8%201.8%202.8%204.3%202.8%206.8s-1%205-2.8%206.8l-7.5%207.5C386%20262%20384%20266.9%20384%20272s2%2010%205.7%2013.7L408%20304c10.2%2010.2%2024.1%2016%2038.6%2016l7.3%200c6.5-20.2%2010-41.7%2010-64c0-111.4-87.6-202.4-197.7-207.7zm172%20307.9c-3.7-2.6-8.2-4.1-13-4.1c-6%200-11.8-2.4-16-6.6L396%20332c-7.7-7.7-18-12-28.9-12c-9.7%200-19.2-3.5-26.6-9.8L314%20287.4c-11.6-9.9-26.4-15.4-41.7-15.4l-20.9%200c-12.6%200-25%203.7-35.5%2010.7L188.5%20301c-17.8%2011.9-28.5%2031.9-28.5%2053.3l0%203.2c0%2017%206.7%2033.3%2018.7%2045.3l16%2016c8.5%208.5%2020%2013.3%2032%2013.3l21.3%200c13.3%200%2024%2010.7%2024%2024c0%202.5%20.4%205%201.1%207.3c71.3-5.8%20132.5-47.6%20165.2-107.2zM0%20256a256%20256%200%201%201%20512%200A256%20256%200%201%201%200%20256zM187.3%20100.7c-6.2-6.2-16.4-6.2-22.6%200l-32%2032c-6.2%206.2-6.2%2016.4%200%2022.6s16.4%206.2%2022.6%200l32-32c6.2-6.2%206.2-16.4%200-22.6z'%20/%3e%3c/svg%3e", zs = [{ name: "Assistant", href: "/assist", icon: Rs }, { name: "Notes", href: "/notes", icon: Ts }, { name: "Web sources", href: "/web-sources", icon: Ps }]; var Es = T('<img class="w-4 h-4">'), Is = T("<li>"), Os = T('<div class=flex><nav class="bg-zinc-900 h-screen w-80 text-white py-4 shadow-md z-50"><ul></ul></nav><div class="h-screen w-screen overflow-y-scroll bg-zinc-800 text-white">'); function Ns(n) { const e = t => (() => { var s = Is(); return E(s, D(Ls, { class: "flex items-center gap-x-2 text-white hover:opacity-80 transition-opacity px-4 py-2", activeClass: "bg-zinc-700", get href() { return t.href }, get children() { return [(() => { var r = Es(); return I(() => de(r, "src", t.icon)), r })(), " ", x(() => t.name)] } })), s })(); return (() => { var t = Os(), s = t.firstChild, r = s.firstChild, i = s.nextSibling; return E(r, () => zs.map(e)), E(i, () => n.children), t })() } function gt() { return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null } } let xe = gt(); function rn(n) { xe = n } const Ae = { exec: () => null }; function A(n, e = "") { let t = typeof n == "string" ? n : n.source; const s = { replace: (r, i) => { let o = typeof i == "string" ? i : i.source; return o = o.replace(W.caret, "$1"), t = t.replace(r, o), s }, getRegex: () => new RegExp(t, e) }; return s } const W = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: n => new RegExp(`^( {0,3}${n})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: n => new RegExp(`^ {0,${Math.min(3, n - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: n => new RegExp(`^ {0,${Math.min(3, n - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: n => new RegExp(`^ {0,${Math.min(3, n - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: n => new RegExp(`^ {0,${Math.min(3, n - 1)}}#`), htmlBeginRegex: n => new RegExp(`^ {0,${Math.min(3, n - 1)}}<(?:[a-z].*>|!--)`, "i") }, Bs = /^(?:[ \t]*(?:\n|$))+/, Fs = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Ds = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, Pe = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Ms = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, mt = /(?:[*+-]|\d{1,9}[.)])/, on = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, ln = A(on).replace(/bull/g, mt).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), js = A(on).replace(/bull/g, mt).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), bt = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, qs = /^[^\n]+/, wt = /(?!\s*\])(?:\\.|[^\[\]\\])+/, Us = A(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", wt).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Hs = A(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, mt).getRegex(), Ve = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", xt = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Zs = A("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", xt).replace("tag", Ve).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), an = A(bt).replace("hr", Pe).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ve).getRegex(), Gs = A(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", an).getRegex(), kt = { blockquote: Gs, code: Fs, def: Us, fences: Ds, heading: Ms, hr: Pe, html: Zs, lheading: ln, list: Hs, newline: Bs, paragraph: an, table: Ae, text: qs }, zt = A("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", Pe).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ve).getRegex(), Ws = { ...kt, lheading: js, table: zt, paragraph: A(bt).replace("hr", Pe).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", zt).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Ve).getRegex() }, Ks = {
    ...kt, html: A(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", xt).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: Ae, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: A(bt).replace("hr", Pe).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", ln).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, Qs = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Vs = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, cn = /^( {2,}|\\)\n(?!\s*$)/, Ys = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, Ye = /[\p{P}\p{S}]/u, yt = /[\s\p{P}\p{S}]/u, un = /[^\s\p{P}\p{S}]/u, Xs = A(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, yt).getRegex(), fn = /(?!~)[\p{P}\p{S}]/u, Js = /(?!~)[\s\p{P}\p{S}]/u, er = /(?:[^\s\p{P}\p{S}]|~)/u, tr = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, hn = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, nr = A(hn, "u").replace(/punct/g, Ye).getRegex(), sr = A(hn, "u").replace(/punct/g, fn).getRegex(), dn = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", rr = A(dn, "gu").replace(/notPunctSpace/g, un).replace(/punctSpace/g, yt).replace(/punct/g, Ye).getRegex(), ir = A(dn, "gu").replace(/notPunctSpace/g, er).replace(/punctSpace/g, Js).replace(/punct/g, fn).getRegex(), or = A("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, un).replace(/punctSpace/g, yt).replace(/punct/g, Ye).getRegex(), lr = A(/\\(punct)/, "gu").replace(/punct/g, Ye).getRegex(), ar = A(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), cr = A(xt).replace("(?:-->|$)", "-->").getRegex(), ur = A("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", cr).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), qe = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, fr = A(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", qe).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), pn = A(/^!?\[(label)\]\[(ref)\]/).replace("label", qe).replace("ref", wt).getRegex(), gn = A(/^!?\[(ref)\](?:\[\])?/).replace("ref", wt).getRegex(), hr = A("reflink|nolink(?!\\()", "g").replace("reflink", pn).replace("nolink", gn).getRegex(), vt = { _backpedal: Ae, anyPunctuation: lr, autolink: ar, blockSkip: tr, br: cn, code: Vs, del: Ae, emStrongLDelim: nr, emStrongRDelimAst: rr, emStrongRDelimUnd: or, escape: Qs, link: fr, nolink: gn, punctuation: Xs, reflink: pn, reflinkSearch: hr, tag: ur, text: Ys, url: Ae }, dr = { ...vt, link: A(/^!?\[(label)\]\((.*?)\)/).replace("label", qe).getRegex(), reflink: A(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", qe).getRegex() }, lt = { ...vt, emStrongRDelimAst: ir, emStrongLDelim: sr, url: A(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, pr = { ...lt, br: A(cn).replace("{2,}", "*").getRegex(), text: A(lt.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, Ie = { normal: kt, gfm: Ws, pedantic: Ks }, $e = { normal: vt, gfm: lt, breaks: pr, pedantic: dr }, gr = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Et = n => gr[n]; function oe(n, e) { if (e) { if (W.escapeTest.test(n)) return n.replace(W.escapeReplace, Et) } else if (W.escapeTestNoEncode.test(n)) return n.replace(W.escapeReplaceNoEncode, Et); return n } function It(n) { try { n = encodeURI(n).replace(W.percentDecode, "%") } catch { return null } return n } function Ot(n, e) { const t = n.replace(W.findPipe, (i, o, l) => { let a = !1, c = o; for (; --c >= 0 && l[c] === "\\";)a = !a; return a ? "|" : " |" }), s = t.split(W.splitPipe); let r = 0; if (s[0].trim() || s.shift(), s.length > 0 && !s.at(-1)?.trim() && s.pop(), e) if (s.length > e) s.splice(e); else for (; s.length < e;)s.push(""); for (; r < s.length; r++)s[r] = s[r].trim().replace(W.slashPipe, "|"); return s } function Se(n, e, t) { const s = n.length; if (s === 0) return ""; let r = 0; for (; r < s && n.charAt(s - r - 1) === e;)r++; return n.slice(0, s - r) } function mr(n, e) { if (n.indexOf(e[1]) === -1) return -1; let t = 0; for (let s = 0; s < n.length; s++)if (n[s] === "\\") s++; else if (n[s] === e[0]) t++; else if (n[s] === e[1] && (t--, t < 0)) return s; return t > 0 ? -2 : -1 } function Nt(n, e, t, s, r) { const i = e.href, o = e.title || null, l = n[1].replace(r.other.outputLinkReplace, "$1"); if (n[0].charAt(0) !== "!") { s.state.inLink = !0; const a = { type: "link", raw: t, href: i, title: o, text: l, tokens: s.inlineTokens(l) }; return s.state.inLink = !1, a } return { type: "image", raw: t, href: i, title: o, text: l } } function br(n, e, t) {
    const s = n.match(t.other.indentCodeCompensation); if (s === null) return e; const r = s[1]; return e.split(`
`).map(i => { const o = i.match(t.other.beginningSpace); if (o === null) return i; const [l] = o; return l.length >= r.length ? i.slice(r.length) : i }).join(`
`)
} class Ue {
    options; rules; lexer; constructor(e) { this.options = e || xe } space(e) { const t = this.rules.block.newline.exec(e); if (t && t[0].length > 0) return { type: "space", raw: t[0] } } code(e) {
        const t = this.rules.block.code.exec(e); if (t) {
            const s = t[0].replace(this.rules.other.codeRemoveIndent, ""); return {
                type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? s : Se(s, `
`)
            }
        }
    } fences(e) { const t = this.rules.block.fences.exec(e); if (t) { const s = t[0], r = br(s, t[3] || "", this.rules); return { type: "code", raw: s, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: r } } } heading(e) { const t = this.rules.block.heading.exec(e); if (t) { let s = t[2].trim(); if (this.rules.other.endingHash.test(s)) { const r = Se(s, "#"); (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (s = r.trim()) } return { type: "heading", raw: t[0], depth: t[1].length, text: s, tokens: this.lexer.inline(s) } } } hr(e) {
        const t = this.rules.block.hr.exec(e); if (t) return {
            type: "hr", raw: Se(t[0], `
`)
        }
    } blockquote(e) {
        const t = this.rules.block.blockquote.exec(e); if (t) {
            let s = Se(t[0], `
`).split(`
`), r = "", i = ""; const o = []; for (; s.length > 0;) {
                let l = !1; const a = []; let c; for (c = 0; c < s.length; c++)if (this.rules.other.blockquoteStart.test(s[c])) a.push(s[c]), l = !0; else if (!l) a.push(s[c]); else break; s = s.slice(c); const f = a.join(`
`), u = f.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, ""); r = r ? `${r}
${f}` : f, i = i ? `${i}
${u}` : u; const d = this.lexer.state.top; if (this.lexer.state.top = !0, this.lexer.blockTokens(u, o, !0), this.lexer.state.top = d, s.length === 0) break; const p = o.at(-1); if (p?.type === "code") break; if (p?.type === "blockquote") {
                    const m = p, h = m.raw + `
`+ s.join(`
`), g = this.blockquote(h); o[o.length - 1] = g, r = r.substring(0, r.length - m.raw.length) + g.raw, i = i.substring(0, i.length - m.text.length) + g.text; break
                } else if (p?.type === "list") {
                    const m = p, h = m.raw + `
`+ s.join(`
`), g = this.list(h); o[o.length - 1] = g, r = r.substring(0, r.length - p.raw.length) + g.raw, i = i.substring(0, i.length - m.raw.length) + g.raw, s = h.substring(o.at(-1).raw.length).split(`
`); continue
                }
            } return { type: "blockquote", raw: r, tokens: o, text: i }
        }
    } list(e) {
        let t = this.rules.block.list.exec(e); if (t) {
            let s = t[1].trim(); const r = s.length > 1, i = { type: "list", raw: "", ordered: r, start: r ? +s.slice(0, -1) : "", loose: !1, items: [] }; s = r ? `\\d{1,9}\\${s.slice(-1)}` : `\\${s}`, this.options.pedantic && (s = r ? s : "[*+-]"); const o = this.rules.other.listItemRegex(s); let l = !1; for (; e;) {
                let c = !1, f = "", u = ""; if (!(t = o.exec(e)) || this.rules.block.hr.test(e)) break; f = t[0], e = e.substring(f.length); let d = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, b => " ".repeat(3 * b.length)), p = e.split(`
`, 1)[0], m = !d.trim(), h = 0; if (this.options.pedantic ? (h = 2, u = d.trimStart()) : m ? h = t[1].length + 1 : (h = t[2].search(this.rules.other.nonSpaceChar), h = h > 4 ? 1 : h, u = d.slice(h), h += t[1].length), m && this.rules.other.blankLine.test(p) && (f += p + `
`, e = e.substring(p.length + 1), c = !0), !c) {
                    const b = this.rules.other.nextBulletRegex(h), P = this.rules.other.hrRegex(h), R = this.rules.other.fencesBeginRegex(h), N = this.rules.other.headingBeginRegex(h), H = this.rules.other.htmlBeginRegex(h); for (; e;) {
                        const ee = e.split(`
`, 1)[0]; let te; if (p = ee, this.options.pedantic ? (p = p.replace(this.rules.other.listReplaceNesting, "  "), te = p) : te = p.replace(this.rules.other.tabCharGlobal, "    "), R.test(p) || N.test(p) || H.test(p) || b.test(p) || P.test(p)) break; if (te.search(this.rules.other.nonSpaceChar) >= h || !p.trim()) u += `
`+ te.slice(h); else {
                            if (m || d.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || R.test(d) || N.test(d) || P.test(d)) break; u += `
`+ p
                        } !m && !p.trim() && (m = !0), f += ee + `
`, e = e.substring(ee.length + 1), d = te.slice(h)
                    }
                } i.loose || (l ? i.loose = !0 : this.rules.other.doubleBlankLine.test(f) && (l = !0)); let g = null, k; this.options.gfm && (g = this.rules.other.listIsTask.exec(u), g && (k = g[0] !== "[ ] ", u = u.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: f, task: !!g, checked: k, loose: !1, text: u, tokens: [] }), i.raw += f
            } const a = i.items.at(-1); if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd(); else return; i.raw = i.raw.trimEnd(); for (let c = 0; c < i.items.length; c++)if (this.lexer.state.top = !1, i.items[c].tokens = this.lexer.blockTokens(i.items[c].text, []), !i.loose) { const f = i.items[c].tokens.filter(d => d.type === "space"), u = f.length > 0 && f.some(d => this.rules.other.anyLine.test(d.raw)); i.loose = u } if (i.loose) for (let c = 0; c < i.items.length; c++)i.items[c].loose = !0; return i
        }
    } html(e) { const t = this.rules.block.html.exec(e); if (t) return { type: "html", block: !0, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] } } def(e) { const t = this.rules.block.def.exec(e); if (t) { const s = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3]; return { type: "def", tag: s, raw: t[0], href: r, title: i } } } table(e) {
        const t = this.rules.block.table.exec(e); if (!t || !this.rules.other.tableDelimiter.test(t[2])) return; const s = Ot(t[1]), r = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], o = { type: "table", raw: t[0], header: [], align: [], rows: [] }; if (s.length === r.length) { for (const l of r) this.rules.other.tableAlignRight.test(l) ? o.align.push("right") : this.rules.other.tableAlignCenter.test(l) ? o.align.push("center") : this.rules.other.tableAlignLeft.test(l) ? o.align.push("left") : o.align.push(null); for (let l = 0; l < s.length; l++)o.header.push({ text: s[l], tokens: this.lexer.inline(s[l]), header: !0, align: o.align[l] }); for (const l of i) o.rows.push(Ot(l, o.header.length).map((a, c) => ({ text: a, tokens: this.lexer.inline(a), header: !1, align: o.align[c] }))); return o }
    } lheading(e) { const t = this.rules.block.lheading.exec(e); if (t) return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) } } paragraph(e) {
        const t = this.rules.block.paragraph.exec(e); if (t) {
            const s = t[1].charAt(t[1].length - 1) === `
`? t[1].slice(0, -1) : t[1]; return { type: "paragraph", raw: t[0], text: s, tokens: this.lexer.inline(s) }
        }
    } text(e) { const t = this.rules.block.text.exec(e); if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) } } escape(e) { const t = this.rules.inline.escape.exec(e); if (t) return { type: "escape", raw: t[0], text: t[1] } } tag(e) { const t = this.rules.inline.tag.exec(e); if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: t[0] } } link(e) { const t = this.rules.inline.link.exec(e); if (t) { const s = t[2].trim(); if (!this.options.pedantic && this.rules.other.startAngleBracket.test(s)) { if (!this.rules.other.endAngleBracket.test(s)) return; const o = Se(s.slice(0, -1), "\\"); if ((s.length - o.length) % 2 === 0) return } else { const o = mr(t[2], "()"); if (o === -2) return; if (o > -1) { const a = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + o; t[2] = t[2].substring(0, o), t[0] = t[0].substring(0, a).trim(), t[3] = "" } } let r = t[2], i = ""; if (this.options.pedantic) { const o = this.rules.other.pedanticHrefTitle.exec(r); o && (r = o[1], i = o[3]) } else i = t[3] ? t[3].slice(1, -1) : ""; return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(s) ? r = r.slice(1) : r = r.slice(1, -1)), Nt(t, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer, this.rules) } } reflink(e, t) { let s; if ((s = this.rules.inline.reflink.exec(e)) || (s = this.rules.inline.nolink.exec(e))) { const r = (s[2] || s[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = t[r.toLowerCase()]; if (!i) { const o = s[0].charAt(0); return { type: "text", raw: o, text: o } } return Nt(s, i, s[0], this.lexer, this.rules) } } emStrong(e, t, s = "") { let r = this.rules.inline.emStrongLDelim.exec(e); if (!r || r[3] && s.match(this.rules.other.unicodeAlphaNumeric)) return; if (!(r[1] || r[2] || "") || !s || this.rules.inline.punctuation.exec(s)) { const o = [...r[0]].length - 1; let l, a, c = o, f = 0; const u = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd; for (u.lastIndex = 0, t = t.slice(-1 * e.length + o); (r = u.exec(t)) != null;) { if (l = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !l) continue; if (a = [...l].length, r[3] || r[4]) { c += a; continue } else if ((r[5] || r[6]) && o % 3 && !((o + a) % 3)) { f += a; continue } if (c -= a, c > 0) continue; a = Math.min(a, a + c + f); const d = [...r[0]][0].length, p = e.slice(0, o + r.index + d + a); if (Math.min(o, a) % 2) { const h = p.slice(1, -1); return { type: "em", raw: p, text: h, tokens: this.lexer.inlineTokens(h) } } const m = p.slice(2, -2); return { type: "strong", raw: p, text: m, tokens: this.lexer.inlineTokens(m) } } } } codespan(e) { const t = this.rules.inline.code.exec(e); if (t) { let s = t[2].replace(this.rules.other.newLineCharGlobal, " "); const r = this.rules.other.nonSpaceChar.test(s), i = this.rules.other.startingSpaceChar.test(s) && this.rules.other.endingSpaceChar.test(s); return r && i && (s = s.substring(1, s.length - 1)), { type: "codespan", raw: t[0], text: s } } } br(e) { const t = this.rules.inline.br.exec(e); if (t) return { type: "br", raw: t[0] } } del(e) { const t = this.rules.inline.del.exec(e); if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) } } autolink(e) { const t = this.rules.inline.autolink.exec(e); if (t) { let s, r; return t[2] === "@" ? (s = t[1], r = "mailto:" + s) : (s = t[1], r = s), { type: "link", raw: t[0], text: s, href: r, tokens: [{ type: "text", raw: s, text: s }] } } } url(e) { let t; if (t = this.rules.inline.url.exec(e)) { let s, r; if (t[2] === "@") s = t[0], r = "mailto:" + s; else { let i; do i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? ""; while (i !== t[0]); s = t[0], t[1] === "www." ? r = "http://" + t[0] : r = t[0] } return { type: "link", raw: t[0], text: s, href: r, tokens: [{ type: "text", raw: s, text: s }] } } } inlineText(e) { const t = this.rules.inline.text.exec(e); if (t) { const s = this.lexer.state.inRawBlock; return { type: "text", raw: t[0], text: t[0], escaped: s } } }
} class Y {
    tokens; options; state; tokenizer; inlineQueue; constructor(e) { this.tokens = [], this.tokens.links = Object.create(null), this.options = e || xe, this.options.tokenizer = this.options.tokenizer || new Ue, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 }; const t = { other: W, block: Ie.normal, inline: $e.normal }; this.options.pedantic ? (t.block = Ie.pedantic, t.inline = $e.pedantic) : this.options.gfm && (t.block = Ie.gfm, this.options.breaks ? t.inline = $e.breaks : t.inline = $e.gfm), this.tokenizer.rules = t } static get rules() { return { block: Ie, inline: $e } } static lex(e, t) { return new Y(t).lex(e) } static lexInline(e, t) { return new Y(t).inlineTokens(e) } lex(e) {
        e = e.replace(W.carriageReturn, `
`), this.blockTokens(e, this.tokens); for (let t = 0; t < this.inlineQueue.length; t++) { const s = this.inlineQueue[t]; this.inlineTokens(s.src, s.tokens) } return this.inlineQueue = [], this.tokens
    } blockTokens(e, t = [], s = !1) {
        for (this.options.pedantic && (e = e.replace(W.tabCharGlobal, "    ").replace(W.spaceLine, "")); e;) {
            let r; if (this.options.extensions?.block?.some(o => (r = o.call({ lexer: this }, e, t)) ? (e = e.substring(r.raw.length), t.push(r), !0) : !1)) continue; if (r = this.tokenizer.space(e)) {
                e = e.substring(r.raw.length); const o = t.at(-1); r.raw.length === 1 && o !== void 0 ? o.raw += `
`: t.push(r); continue
            } if (r = this.tokenizer.code(e)) {
                e = e.substring(r.raw.length); const o = t.at(-1); o?.type === "paragraph" || o?.type === "text" ? (o.raw += `
`+ r.raw, o.text += `
`+ r.text, this.inlineQueue.at(-1).src = o.text) : t.push(r); continue
            } if (r = this.tokenizer.fences(e)) { e = e.substring(r.raw.length), t.push(r); continue } if (r = this.tokenizer.heading(e)) { e = e.substring(r.raw.length), t.push(r); continue } if (r = this.tokenizer.hr(e)) { e = e.substring(r.raw.length), t.push(r); continue } if (r = this.tokenizer.blockquote(e)) { e = e.substring(r.raw.length), t.push(r); continue } if (r = this.tokenizer.list(e)) { e = e.substring(r.raw.length), t.push(r); continue } if (r = this.tokenizer.html(e)) { e = e.substring(r.raw.length), t.push(r); continue } if (r = this.tokenizer.def(e)) {
                e = e.substring(r.raw.length); const o = t.at(-1); o?.type === "paragraph" || o?.type === "text" ? (o.raw += `
`+ r.raw, o.text += `
`+ r.raw, this.inlineQueue.at(-1).src = o.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = { href: r.href, title: r.title }); continue
            } if (r = this.tokenizer.table(e)) { e = e.substring(r.raw.length), t.push(r); continue } if (r = this.tokenizer.lheading(e)) { e = e.substring(r.raw.length), t.push(r); continue } let i = e; if (this.options.extensions?.startBlock) { let o = 1 / 0; const l = e.slice(1); let a; this.options.extensions.startBlock.forEach(c => { a = c.call({ lexer: this }, l), typeof a == "number" && a >= 0 && (o = Math.min(o, a)) }), o < 1 / 0 && o >= 0 && (i = e.substring(0, o + 1)) } if (this.state.top && (r = this.tokenizer.paragraph(i))) {
                const o = t.at(-1); s && o?.type === "paragraph" ? (o.raw += `
`+ r.raw, o.text += `
`+ r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = o.text) : t.push(r), s = i.length !== e.length, e = e.substring(r.raw.length); continue
            } if (r = this.tokenizer.text(e)) {
                e = e.substring(r.raw.length); const o = t.at(-1); o?.type === "text" ? (o.raw += `
`+ r.raw, o.text += `
`+ r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = o.text) : t.push(r); continue
            } if (e) { const o = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(o); break } else throw new Error(o) }
        } return this.state.top = !0, t
    } inline(e, t = []) { return this.inlineQueue.push({ src: e, tokens: t }), t } inlineTokens(e, t = []) { let s = e, r = null; if (this.tokens.links) { const l = Object.keys(this.tokens.links); if (l.length > 0) for (; (r = this.tokenizer.rules.inline.reflinkSearch.exec(s)) != null;)l.includes(r[0].slice(r[0].lastIndexOf("[") + 1, -1)) && (s = s.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + s.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex)) } for (; (r = this.tokenizer.rules.inline.anyPunctuation.exec(s)) != null;)s = s.slice(0, r.index) + "++" + s.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex); for (; (r = this.tokenizer.rules.inline.blockSkip.exec(s)) != null;)s = s.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + s.slice(this.tokenizer.rules.inline.blockSkip.lastIndex); let i = !1, o = ""; for (; e;) { i || (o = ""), i = !1; let l; if (this.options.extensions?.inline?.some(c => (l = c.call({ lexer: this }, e, t)) ? (e = e.substring(l.raw.length), t.push(l), !0) : !1)) continue; if (l = this.tokenizer.escape(e)) { e = e.substring(l.raw.length), t.push(l); continue } if (l = this.tokenizer.tag(e)) { e = e.substring(l.raw.length), t.push(l); continue } if (l = this.tokenizer.link(e)) { e = e.substring(l.raw.length), t.push(l); continue } if (l = this.tokenizer.reflink(e, this.tokens.links)) { e = e.substring(l.raw.length); const c = t.at(-1); l.type === "text" && c?.type === "text" ? (c.raw += l.raw, c.text += l.text) : t.push(l); continue } if (l = this.tokenizer.emStrong(e, s, o)) { e = e.substring(l.raw.length), t.push(l); continue } if (l = this.tokenizer.codespan(e)) { e = e.substring(l.raw.length), t.push(l); continue } if (l = this.tokenizer.br(e)) { e = e.substring(l.raw.length), t.push(l); continue } if (l = this.tokenizer.del(e)) { e = e.substring(l.raw.length), t.push(l); continue } if (l = this.tokenizer.autolink(e)) { e = e.substring(l.raw.length), t.push(l); continue } if (!this.state.inLink && (l = this.tokenizer.url(e))) { e = e.substring(l.raw.length), t.push(l); continue } let a = e; if (this.options.extensions?.startInline) { let c = 1 / 0; const f = e.slice(1); let u; this.options.extensions.startInline.forEach(d => { u = d.call({ lexer: this }, f), typeof u == "number" && u >= 0 && (c = Math.min(c, u)) }), c < 1 / 0 && c >= 0 && (a = e.substring(0, c + 1)) } if (l = this.tokenizer.inlineText(a)) { e = e.substring(l.raw.length), l.raw.slice(-1) !== "_" && (o = l.raw.slice(-1)), i = !0; const c = t.at(-1); c?.type === "text" ? (c.raw += l.raw, c.text += l.text) : t.push(l); continue } if (e) { const c = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(c); break } else throw new Error(c) } } return t }
} class He {
    options; parser; constructor(e) { this.options = e || xe } space(e) { return "" } code({ text: e, lang: t, escaped: s }) {
        const r = (t || "").match(W.notSpaceStart)?.[0], i = e.replace(W.endingNewline, "") + `
`; return r ? '<pre><code class="language-' + oe(r) + '">' + (s ? i : oe(i, !0)) + `</code></pre>
`: "<pre><code>" + (s ? i : oe(i, !0)) + `</code></pre>
`} blockquote({ tokens: e }) {
        return `<blockquote>
${this.parser.parse(e)}</blockquote>
`} html({ text: e }) { return e } heading({ tokens: e, depth: t }) {
        return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`} hr(e) {
        return `<hr>
`} list(e) {
        const t = e.ordered, s = e.start; let r = ""; for (let l = 0; l < e.items.length; l++) { const a = e.items[l]; r += this.listitem(a) } const i = t ? "ol" : "ul", o = t && s !== 1 ? ' start="' + s + '"' : ""; return "<" + i + o + `>
`+ r + "</" + i + `>
`} listitem(e) {
        let t = ""; if (e.task) { const s = this.checkbox({ checked: !!e.checked }); e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = s + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = s + " " + oe(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = !0)) : e.tokens.unshift({ type: "text", raw: s + " ", text: s + " ", escaped: !0 }) : t += s + " " } return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`} checkbox({ checked: e }) { return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">' } paragraph({ tokens: e }) {
        return `<p>${this.parser.parseInline(e)}</p>
`} table(e) {
        let t = "", s = ""; for (let i = 0; i < e.header.length; i++)s += this.tablecell(e.header[i]); t += this.tablerow({ text: s }); let r = ""; for (let i = 0; i < e.rows.length; i++) { const o = e.rows[i]; s = ""; for (let l = 0; l < o.length; l++)s += this.tablecell(o[l]); r += this.tablerow({ text: s }) } return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
`+ t + `</thead>
`+ r + `</table>
`} tablerow({ text: e }) {
        return `<tr>
${e}</tr>
`} tablecell(e) {
        const t = this.parser.parseInline(e.tokens), s = e.header ? "th" : "td"; return (e.align ? `<${s} align="${e.align}">` : `<${s}>`) + t + `</${s}>
`} strong({ tokens: e }) { return `<strong>${this.parser.parseInline(e)}</strong>` } em({ tokens: e }) { return `<em>${this.parser.parseInline(e)}</em>` } codespan({ text: e }) { return `<code>${oe(e, !0)}</code>` } br(e) { return "<br>" } del({ tokens: e }) { return `<del>${this.parser.parseInline(e)}</del>` } link({ href: e, title: t, tokens: s }) { const r = this.parser.parseInline(s), i = It(e); if (i === null) return r; e = i; let o = '<a href="' + e + '"'; return t && (o += ' title="' + oe(t) + '"'), o += ">" + r + "</a>", o } image({ href: e, title: t, text: s }) { const r = It(e); if (r === null) return oe(s); e = r; let i = `<img src="${e}" alt="${s}"`; return t && (i += ` title="${oe(t)}"`), i += ">", i } text(e) { return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : oe(e.text) }
} class $t { strong({ text: e }) { return e } em({ text: e }) { return e } codespan({ text: e }) { return e } del({ text: e }) { return e } html({ text: e }) { return e } text({ text: e }) { return e } link({ text: e }) { return "" + e } image({ text: e }) { return "" + e } br() { return "" } } class X {
    options; renderer; textRenderer; constructor(e) { this.options = e || xe, this.options.renderer = this.options.renderer || new He, this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new $t } static parse(e, t) { return new X(t).parse(e) } static parseInline(e, t) { return new X(t).parseInline(e) } parse(e, t = !0) {
        let s = ""; for (let r = 0; r < e.length; r++) {
            const i = e[r]; if (this.options.extensions?.renderers?.[i.type]) { const l = i, a = this.options.extensions.renderers[l.type].call({ parser: this }, l); if (a !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(l.type)) { s += a || ""; continue } } const o = i; switch (o.type) {
                case "space": { s += this.renderer.space(o); continue } case "hr": { s += this.renderer.hr(o); continue } case "heading": { s += this.renderer.heading(o); continue } case "code": { s += this.renderer.code(o); continue } case "table": { s += this.renderer.table(o); continue } case "blockquote": { s += this.renderer.blockquote(o); continue } case "list": { s += this.renderer.list(o); continue } case "html": { s += this.renderer.html(o); continue } case "paragraph": { s += this.renderer.paragraph(o); continue } case "text": {
                    let l = o, a = this.renderer.text(l); for (; r + 1 < e.length && e[r + 1].type === "text";)l = e[++r], a += `
`+ this.renderer.text(l); t ? s += this.renderer.paragraph({ type: "paragraph", raw: a, text: a, tokens: [{ type: "text", raw: a, text: a, escaped: !0 }] }) : s += a; continue
                } default: { const l = 'Token with "' + o.type + '" type was not found.'; if (this.options.silent) return console.error(l), ""; throw new Error(l) }
            }
        } return s
    } parseInline(e, t = this.renderer) { let s = ""; for (let r = 0; r < e.length; r++) { const i = e[r]; if (this.options.extensions?.renderers?.[i.type]) { const l = this.options.extensions.renderers[i.type].call({ parser: this }, i); if (l !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) { s += l || ""; continue } } const o = i; switch (o.type) { case "escape": { s += t.text(o); break } case "html": { s += t.html(o); break } case "link": { s += t.link(o); break } case "image": { s += t.image(o); break } case "strong": { s += t.strong(o); break } case "em": { s += t.em(o); break } case "codespan": { s += t.codespan(o); break } case "br": { s += t.br(o); break } case "del": { s += t.del(o); break } case "text": { s += t.text(o); break } default: { const l = 'Token with "' + o.type + '" type was not found.'; if (this.options.silent) return console.error(l), ""; throw new Error(l) } } } return s }
} class Ne { options; block; constructor(e) { this.options = e || xe } static passThroughHooks = new Set(["preprocess", "postprocess", "processAllTokens"]); preprocess(e) { return e } postprocess(e) { return e } processAllTokens(e) { return e } provideLexer() { return this.block ? Y.lex : Y.lexInline } provideParser() { return this.block ? X.parse : X.parseInline } } class wr {
    defaults = gt(); options = this.setOptions; parse = this.parseMarkdown(!0); parseInline = this.parseMarkdown(!1); Parser = X; Renderer = He; TextRenderer = $t; Lexer = Y; Tokenizer = Ue; Hooks = Ne; constructor(...e) { this.use(...e) } walkTokens(e, t) { let s = []; for (const r of e) switch (s = s.concat(t.call(this, r)), r.type) { case "table": { const i = r; for (const o of i.header) s = s.concat(this.walkTokens(o.tokens, t)); for (const o of i.rows) for (const l of o) s = s.concat(this.walkTokens(l.tokens, t)); break } case "list": { const i = r; s = s.concat(this.walkTokens(i.items, t)); break } default: { const i = r; this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach(o => { const l = i[o].flat(1 / 0); s = s.concat(this.walkTokens(l, t)) }) : i.tokens && (s = s.concat(this.walkTokens(i.tokens, t))) } }return s } use(...e) { const t = this.defaults.extensions || { renderers: {}, childTokens: {} }; return e.forEach(s => { const r = { ...s }; if (r.async = this.defaults.async || r.async || !1, s.extensions && (s.extensions.forEach(i => { if (!i.name) throw new Error("extension name required"); if ("renderer" in i) { const o = t.renderers[i.name]; o ? t.renderers[i.name] = function (...l) { let a = i.renderer.apply(this, l); return a === !1 && (a = o.apply(this, l)), a } : t.renderers[i.name] = i.renderer } if ("tokenizer" in i) { if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'"); const o = t[i.level]; o ? o.unshift(i.tokenizer) : t[i.level] = [i.tokenizer], i.start && (i.level === "block" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [i.start] : i.level === "inline" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [i.start])) } "childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens) }), r.extensions = t), s.renderer) { const i = this.defaults.renderer || new He(this.defaults); for (const o in s.renderer) { if (!(o in i)) throw new Error(`renderer '${o}' does not exist`); if (["options", "parser"].includes(o)) continue; const l = o, a = s.renderer[l], c = i[l]; i[l] = (...f) => { let u = a.apply(i, f); return u === !1 && (u = c.apply(i, f)), u || "" } } r.renderer = i } if (s.tokenizer) { const i = this.defaults.tokenizer || new Ue(this.defaults); for (const o in s.tokenizer) { if (!(o in i)) throw new Error(`tokenizer '${o}' does not exist`); if (["options", "rules", "lexer"].includes(o)) continue; const l = o, a = s.tokenizer[l], c = i[l]; i[l] = (...f) => { let u = a.apply(i, f); return u === !1 && (u = c.apply(i, f)), u } } r.tokenizer = i } if (s.hooks) { const i = this.defaults.hooks || new Ne; for (const o in s.hooks) { if (!(o in i)) throw new Error(`hook '${o}' does not exist`); if (["options", "block"].includes(o)) continue; const l = o, a = s.hooks[l], c = i[l]; Ne.passThroughHooks.has(o) ? i[l] = f => { if (this.defaults.async) return Promise.resolve(a.call(i, f)).then(d => c.call(i, d)); const u = a.call(i, f); return c.call(i, u) } : i[l] = (...f) => { let u = a.apply(i, f); return u === !1 && (u = c.apply(i, f)), u } } r.hooks = i } if (s.walkTokens) { const i = this.defaults.walkTokens, o = s.walkTokens; r.walkTokens = function (l) { let a = []; return a.push(o.call(this, l)), i && (a = a.concat(i.call(this, l))), a } } this.defaults = { ...this.defaults, ...r } }), this } setOptions(e) { return this.defaults = { ...this.defaults, ...e }, this } lexer(e, t) { return Y.lex(e, t ?? this.defaults) } parser(e, t) { return X.parse(e, t ?? this.defaults) } parseMarkdown(e) { return (s, r) => { const i = { ...r }, o = { ...this.defaults, ...i }, l = this.onError(!!o.silent, !!o.async); if (this.defaults.async === !0 && i.async === !1) return l(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.")); if (typeof s > "u" || s === null) return l(new Error("marked(): input parameter is undefined or null")); if (typeof s != "string") return l(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(s) + ", string expected")); o.hooks && (o.hooks.options = o, o.hooks.block = e); const a = o.hooks ? o.hooks.provideLexer() : e ? Y.lex : Y.lexInline, c = o.hooks ? o.hooks.provideParser() : e ? X.parse : X.parseInline; if (o.async) return Promise.resolve(o.hooks ? o.hooks.preprocess(s) : s).then(f => a(f, o)).then(f => o.hooks ? o.hooks.processAllTokens(f) : f).then(f => o.walkTokens ? Promise.all(this.walkTokens(f, o.walkTokens)).then(() => f) : f).then(f => c(f, o)).then(f => o.hooks ? o.hooks.postprocess(f) : f).catch(l); try { o.hooks && (s = o.hooks.preprocess(s)); let f = a(s, o); o.hooks && (f = o.hooks.processAllTokens(f)), o.walkTokens && this.walkTokens(f, o.walkTokens); let u = c(f, o); return o.hooks && (u = o.hooks.postprocess(u)), u } catch (f) { return l(f) } } } onError(e, t) {
        return s => {
            if (s.message += `
Please report this to https://github.com/markedjs/marked.`, e) { const r = "<p>An error occurred:</p><pre>" + oe(s.message + "", !0) + "</pre>"; return t ? Promise.resolve(r) : r } if (t) return Promise.reject(s); throw s
        }
    }
} const we = new wr; function L(n, e) { return we.parse(n, e) } L.options = L.setOptions = function (n) { return we.setOptions(n), L.defaults = we.defaults, rn(L.defaults), L }; L.getDefaults = gt; L.defaults = xe; L.use = function (...n) { return we.use(...n), L.defaults = we.defaults, rn(L.defaults), L }; L.walkTokens = function (n, e) { return we.walkTokens(n, e) }; L.parseInline = we.parseInline; L.Parser = X; L.parser = X.parse; L.Renderer = He; L.TextRenderer = $t; L.Lexer = Y; L.lexer = Y.lex; L.Tokenizer = Ue; L.Hooks = Ne; L.parse = L; L.options; L.setOptions; L.use; L.walkTokens; L.parseInline; X.parse; Y.lex; var xr = T('<div class="flex-1 p-4 overflow-y-auto"><div class=max-w-full><div class=markdown-preview>'); function Ce(n) { return (() => { var e = xr(), t = e.firstChild, s = t.firstChild; return I(() => s.innerHTML = L.parse(n.content)), e })() } var kr = T('<div class=mb-6><div class="font-semibold text-blue-400 mb-1">You:</div><div class="font-semibold text-green-400 mt-2 mb-1">AI:'), yr = T('<div class="max-w-3xl mx-auto py-8 px-4"><h1 class="text-3xl font-bold mb-4">Assist AI</h1><div class="mb-6 p-4 rounded bg-zinc-900 border border-zinc-700"><p>Assist AI runs locally and answers your questions using the provided documents (in Markdown format) and your chat history. With efficient RAG, the model can use a large number of notes as context. You can also ask questions without RAG for faster responses.<br>You can manage your documents in the <a href=/notes class="font-semibold text-blue-400 cursor-pointer">Notes</a> and <span href=/web-sources class="font-semibold text-blue-400 cursor-pointer">Web Sources</span> tabs on the left.</p></div><form class=mb-6><div class="flex gap-2 mb-2"><input type=text name=question placeholder="Enter your question"class="flex-1 px-4 py-2 rounded bg-zinc-800 border border-zinc-700 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"required><button type=submit class="px-4 py-2 rounded bg-blue-600 text-white font-semibold hover:bg-blue-700 transition cursor-pointer">Ask</button><button type=button class="px-4 py-2 rounded bg-zinc-700 text-white font-semibold hover:bg-zinc-600 transition cursor-pointer">Clear</button></div><div class="flex items-center gap-2"><input type=checkbox id=useRag class="form-checkbox accent-blue-600"><label for=useRag class="text-sm text-zinc-300">Provide answer based on documents</label></div></form><div class=mb-6><textarea class="w-full p-2 rounded bg-zinc-800 border border-zinc-700 text-white mb-2"placeholder="Add a custom note to include in the saved note (will be saved for next time)..."rows=2></textarea><button type=button class="px-4 py-2 rounded bg-green-600 text-white font-semibold hover:bg-green-700 transition cursor-pointer">Save Conversation as Note'), vr = T('<div class="flex items-center justify-center w-full gap-2 mb-4"><div class=loader></div><span class="text-blue-400 font-semibold">Loading... <!>s'), $r = T('<div class=mb-8><h2 class="text-xl font-bold mb-2">Response:'), Sr = T('<div class="mb-4 text-green-400 font-semibold">Conversation saved as note!'), _r = T('<div class="bg-zinc-900 border border-zinc-700 rounded p-4"><div class="flex items-center justify-between mb-4"><h2 class="text-lg font-bold">Chat History</h2></div><div class="max-h-96 overflow-y-auto">'); function Ar() {
    const [n, e] = S(""), [t, s] = S(!0), [r, i] = S(localStorage.getItem("assistai_save_note_extra") || ""), [o, l] = S(""), [a, c] = S([]), [f, u] = S(!1), [d, p] = S(0), [m, h] = S(!1); let g = null; const k = () => { u(!0), p(0); const v = Date.now(); g = setInterval(() => { p(((Date.now() - v) / 1e3).toFixed(1)) }, 100) }, b = () => { u(!1), g && clearInterval(g) }; We(() => { g && clearInterval(g) }), Ge(() => { P(); const v = localStorage.getItem("assist-message"); e(v || "") }); const P = async () => { const v = await fetch("/api/history"); if (!v.ok) { console.error("Failed to fetch history"); return } const B = await v.json(); c(B.history || []) }, R = async v => { v.preventDefault(), k(); const B = new FormData; B.append("question", n()), B.append("use_rag", t() ? "on" : "off"), B.append("clear", "false"); const Z = await (await fetch("/api/question", { method: "POST", body: B })).json(); l(Z.response || ""), c(Z.history || []), b(), e(""), localStorage.setItem("assist-message", "") }, N = async () => { k(); const v = new FormData; v.append("question", ""), v.append("use_rag", t() ? "on" : "off"), v.append("clear", "true"); const V = await (await fetch("/api/question", { method: "POST", body: v })).json(); l(""), i(""), c(V.history || []), e(""), b() }, H = v => { i(v.target.value), localStorage.setItem("assistai_save_note_extra", v.target.value) }, ee = async () => {
        const v = new Date, B = v.toISOString().replace(/[:.]/g, "-").slice(0, 19), V = `${B.split("T")[0]}_${B.split("T")[1]}_assistai_note.md`; let Z = `# Assist AI Conversation (${v.toLocaleString()})

`; const se = r(); se && se.trim().length > 0 && (Z += `> ${se.trim().replace(/\n/g, `
> `)}

`), [...a()].reverse().forEach(([O, j], M) => {
            Z += `## Q${M + 1}
${O}

## A${M + 1}
${j}

`}); const $ = new FormData; $.append("filename", V), $.append("content", Z), (await fetch("/api/files", { method: "POST", body: $ })).ok && (h(!0), setTimeout(() => h(!1), 5e3))
    }, te = v => (() => { var B = kr(), V = B.firstChild, Z = V.nextSibling; return E(B, D(Ce, { get content() { return v[0] } }), Z), E(B, D(Ce, { get content() { return v[1] } }), null), B })(); return (() => { var v = yr(), B = v.firstChild, V = B.nextSibling, Z = V.nextSibling, se = Z.firstChild, y = se.firstChild, $ = y.nextSibling, w = $.nextSibling, O = se.nextSibling, j = O.firstChild, M = Z.nextSibling, re = M.firstChild, le = re.nextSibling; return Z.addEventListener("submit", R), y.$$input = C => e(C.target.value), w.$$click = N, j.addEventListener("change", C => s(C.target.checked)), E(v, (() => { var C = x(() => !!f()); return () => C() && (() => { var q = vr(), ue = q.firstChild, ie = ue.nextSibling, U = ie.firstChild, F = U.nextSibling; return F.nextSibling, E(ie, d, F), q })() })(), M), E(v, (() => { var C = x(() => !!(o() && !f())); return () => C() && (() => { var q = $r(); return q.firstChild, E(q, D(Ce, { get content() { return o() } }), null), q })() })(), M), E(v, (() => { var C = x(() => !!m()); return () => C() && Sr() })(), M), re.$$input = H, le.$$click = ee, E(v, (() => { var C = x(() => a().length > 0); return () => C() && (() => { var q = _r(), ue = q.firstChild, ie = ue.nextSibling; return E(ie, D(zn, { get each() { return [...a()].reverse() }, children: te })), q })() })(), null), I(C => { var q = f(), ue = f(), ie = f(), U = f(); return q !== C.e && (y.disabled = C.e = q), ue !== C.t && ($.disabled = C.t = ue), ie !== C.a && (w.disabled = C.a = ie), U !== C.o && (j.disabled = C.o = U), C }, { e: void 0, t: void 0, a: void 0, o: void 0 }), I(() => y.value = n()), I(() => j.checked = t()), I(() => re.value = r()), v })()
} ye(["input", "click"]); const Cr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20448%20512'%3e%3c!--!%20Font%20Awesome%20Free%206.7.2%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20(Icons:%20CC%20BY%204.0,%20Fonts:%20SIL%20OFL%201.1,%20Code:%20MIT%20License)%20Copyright%202024%20Fonticons,%20Inc.%20--%3e%3cpath%20fill='%23ffffff'%20d='M256%2080c0-17.7-14.3-32-32-32s-32%2014.3-32%2032l0%20144L48%20224c-17.7%200-32%2014.3-32%2032s14.3%2032%2032%2032l144%200%200%20144c0%2017.7%2014.3%2032%2032%2032s32-14.3%2032-32l0-144%20144%200c17.7%200%2032-14.3%2032-32s-14.3-32-32-32l-144%200%200-144z'%20/%3e%3c/svg%3e", Lr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20448%20512'%3e%3c!--!%20Font%20Awesome%20Free%206.7.2%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20(Icons:%20CC%20BY%204.0,%20Fonts:%20SIL%20OFL%201.1,%20Code:%20MIT%20License)%20Copyright%202024%20Fonticons,%20Inc.%20--%3e%3cpath%20fill='%23ffffff'%20d='M135.2%2017.7L128%2032%2032%2032C14.3%2032%200%2046.3%200%2064S14.3%2096%2032%2096l384%200c17.7%200%2032-14.3%2032-32s-14.3-32-32-32l-96%200-7.2-14.3C307.4%206.8%20296.3%200%20284.2%200L163.8%200c-12.1%200-23.2%206.8-28.6%2017.7zM416%20128L32%20128%2053.2%20467c1.6%2025.3%2022.6%2045%2047.9%2045l245.8%200c25.3%200%2046.3-19.7%2047.9-45L416%20128z'%20/%3e%3c/svg%3e", Rr = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3c!--!%20Font%20Awesome%20Free%206.7.2%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20(Icons:%20CC%20BY%204.0,%20Fonts:%20SIL%20OFL%201.1,%20Code:%20MIT%20License)%20Copyright%202024%20Fonticons,%20Inc.%20--%3e%3cpath%20fill='%23ffffff'%20d='M410.3%20231l11.3-11.3-33.9-33.9-62.1-62.1L291.7%2089.8l-11.3%2011.3-22.6%2022.6L58.6%20322.9c-10.4%2010.4-18%2023.3-22.2%2037.4L1%20480.7c-2.5%208.4-.2%2017.5%206.1%2023.7s15.3%208.5%2023.7%206.1l120.3-35.4c14.1-4.2%2027-11.8%2037.4-22.2L387.7%20253.7%20410.3%20231zM160%20399.4l-9.1%2022.7c-4%203.1-8.5%205.4-13.3%206.9L59.4%20452l23-78.1c1.4-4.9%203.8-9.4%206.9-13.3l22.7-9.1%200%2032c0%208.8%207.2%2016%2016%2016l32%200zM362.7%2018.7L348.3%2033.2%20325.7%2055.8%20314.3%2067.1l33.9%2033.9%2062.1%2062.1%2033.9%2033.9%2011.3-11.3%2022.6-22.6%2014.5-14.5c25-25%2025-65.5%200-90.5L453.3%2018.7c-25-25-65.5-25-90.5%200zm-47.4%20168l-144%20144c-6.2%206.2-16.4%206.2-22.6%200s-6.2-16.4%200-22.6l144-144c6.2-6.2%2016.4-6.2%2022.6%200s6.2%2016.4%200%2022.6z'%20/%3e%3c/svg%3e"; var Tr = T("<textarea>"); function Pr(n) { const [e, t] = S(n.value || ""); let s; const r = () => { s && (s.style.height = "auto", s.style.height = s.scrollHeight + "px") }; return Ge(r), Mt(() => { r(), n.onInput?.(e()) }), (() => { var i = Tr(); return i.$$input = o => t(o.currentTarget.value), Qt(o => s = o, i), i.style.setProperty("overflow", "hidden"), i.style.setProperty("resize", "none"), I(o => { var l = n.placeholder, a = n.class; return l !== o.e && de(i, "placeholder", o.e = l), a !== o.t && Ke(i, o.t = a), o }, { e: void 0, t: void 0 }), I(() => i.value = e()), i })() } ye(["input"]); var zr = T('<div class="flex h-full min-h-screen"><aside class="w-80 bg-zinc-800 border-r border-zinc-700 overflow-y-auto h-screen"><div class="flex items-center justify-between px-4 py-5 border-b border-zinc-700"><h2 class="text-xl font-bold">Notes</h2><button class="p-1 rounded-full hover:bg-zinc-700 transition cursor-pointer"title="Add note"><img class="w-6 h-6"alt=Add></button></div><div class="px-4 py-2 border-b border-zinc-700"><input type=text class="w-full px-2 py-1 rounded bg-zinc-700 border border-zinc-600 text-white placeholder-zinc-400 text-sm"placeholder="Filter notes..."></div><ul></ul></aside><main class="flex-1 p-8 overflow-y-auto">'), Er = T("<li><span class=truncate>"), Ir = T('<button class="p-2 rounded-full hover:bg-red-700/50 cursor-pointer"title="Delete note"><img class="w-4 h-4"alt=Delete>'), Or = T('<div class="max-w-2xl mx-auto bg-zinc-900 border border-zinc-700 rounded p-6 mb-8"><h2 class="text-xl font-bold mb-4">Add Note</h2><input class="w-full mb-3 px-3 py-2 rounded bg-zinc-800 border border-zinc-700 text-white"placeholder="Note filename (e.g. my-note.md)"><textarea class="w-full mb-3 px-3 py-2 rounded bg-zinc-800 border border-zinc-700 text-white"rows=10 placeholder="Note content (Markdown supported)"></textarea><div class="flex gap-2"><button class="px-4 py-2 rounded bg-green-600 text-white font-semibold hover:bg-green-700 transition">Save</button><button class="px-4 py-2 rounded bg-zinc-700 text-white font-semibold hover:bg-zinc-600 transition">Cancel'), Nr = T('<div class="flex items-center mb-4"><h1 class="text-2xl font-bold flex-1">'), Br = T('<button class="p-2 rounded-full hover:bg-zinc-700/50 cursor-pointer"title="Edit note"><img class="w-5 h-5"alt=Edit>'), Fr = T('<div class="flex items-center gap-x-2"><div class=loader></div><span class="text-lg font-semibold">Loading...'), Dr = T('<div class=max-w-full><div class="flex gap-2"><button class="px-4 py-2 rounded bg-green-600 text-white font-semibold hover:bg-green-700 transition cursor-pointer">Save</button><button class="px-4 py-2 rounded bg-zinc-700 text-white font-semibold hover:bg-zinc-600 transition cursor-pointer">Cancel'), Mr = T("<p class=text-zinc-400>Select a note to view its content."); function jr() { const [n, e] = S([]), [t, s] = S(null), [r, i] = S(""), [o, l] = S(!1), [a, c] = S(null), [f, u] = S(!1), [d, p] = S(""), [m, h] = S(!1), [g, k] = S(""), [b, P] = S(""), [R, N] = S(""); async function H(w = null) { try { const O = await fetch("/api/files"); if (!O.ok) throw new Error("Network response was not ok"); const j = await O.json(); if (e(j.files), j.files.length > 0) { const M = w || j.files[0]; s(M), ee(M) } else s(null), i("") } catch (O) { console.error("Error fetching notes:", O) } } async function ee(w) { s(w), l(!0), i(""), u(!1); try { const O = await fetch(`/api/files/${encodeURIComponent(w)}`); if (!O.ok) throw new Error("Failed to fetch note content"); const j = await O.text(); i(j) } catch { i("Error loading note.") } l(!1) } async function te(w) { window.confirm(`Delete note "${w}"?`) && (l(!0), await fetch(`/api/files/${encodeURIComponent(w)}`, { method: "DELETE" }), await H(), l(!1)) } function v() { p(r()), u(!0) } function B() { u(!1) } async function V() { l(!0); const w = new FormData; w.append("content", d()), await fetch(`/api/files/${t()}`, { method: "PUT", body: w }), u(!1), await H(t()), l(!1) } function Z() { h(!0), k(""), P("") } function se() { h(!1) } async function y() { if (!g().trim()) return; l(!0); const w = new FormData; w.append("filename", g()), w.append("content", b()), await fetch("/api/files", { method: "POST", body: w }), h(!1), await H(g()), l(!1) } const $ = () => n().filter(w => w.toLowerCase().includes(R().toLowerCase())); return Ge(() => { H() }), (() => { var w = zr(), O = w.firstChild, j = O.firstChild, M = j.firstChild, re = M.nextSibling, le = re.firstChild, C = j.nextSibling, q = C.firstChild, ue = C.nextSibling, ie = O.nextSibling; return re.$$click = Z, de(le, "src", Cr), q.$$input = U => N(U.target.value), E(ue, () => $().map(U => (() => { var F = Er(), fe = F.firstChild; return F.addEventListener("mouseleave", () => c(null)), F.addEventListener("mouseenter", () => c(U)), F.$$click = () => ee(U), E(fe, U), E(F, (() => { var ne = x(() => a() === U); return () => ne() && (() => { var K = Ir(), Q = K.firstChild; return K.$$click = he => { he.stopPropagation(), te(U) }, de(Q, "src", Lr), K })() })(), null), I(() => Ke(F, `group h-14 flex items-center justify-between px-2 py-3 border-b border-zinc-700 cursor-pointer hover:bg-zinc-700 transition-colors ${t() === U ? "bg-zinc-700 font-semibold" : ""}`)), F })())), E(ie, (() => { var U = x(() => !!m()); return () => U() && (() => { var F = Or(), fe = F.firstChild, ne = fe.nextSibling, K = ne.nextSibling, Q = K.nextSibling, he = Q.firstChild, ve = he.nextSibling; return ne.$$input = ae => k(ae.target.value), K.$$input = ae => P(ae.target.value), he.$$click = y, ve.$$click = se, I(ae => { var St = o(), _t = o(); return St !== ae.e && (he.disabled = ae.e = St), _t !== ae.t && (ve.disabled = ae.t = _t), ae }, { e: void 0, t: void 0 }), I(() => ne.value = g()), I(() => K.value = b()), F })() })(), null), E(ie, (() => { var U = x(() => !!(t() && !m())); return () => U() ? [(() => { var F = Nr(), fe = F.firstChild; return E(fe, t), E(F, (() => { var ne = x(() => !f()); return () => ne() && (() => { var K = Br(), Q = K.firstChild; return K.$$click = v, de(Q, "src", Rr), K })() })(), null), F })(), x(() => x(() => !!o())() ? Fr() : x(() => !!f())() ? (() => { var F = Dr(), fe = F.firstChild, ne = fe.firstChild, K = ne.nextSibling; return E(F, D(Pr, { class: "w-full mb-3 px-3 py-2 rounded bg-zinc-800 border border-zinc-700 text-white", get value() { return d() }, onInput: Q => p(Q) }), fe), ne.$$click = V, K.$$click = B, I(Q => { var he = o(), ve = o(); return he !== Q.e && (ne.disabled = Q.e = he), ve !== Q.t && (K.disabled = Q.t = ve), Q }, { e: void 0, t: void 0 }), F })() : D(Ce, { get content() { return r() } }))] : x(() => !m())() ? Mr() : null })(), null), I(() => q.value = R()), w })() } ye(["click", "input"]); var qr = T('<div class="flex h-full min-h-screen"><aside class="w-72 bg-zinc-800 border-r border-zinc-700 overflow-y-auto h-screen"><h2 class="text-xl font-bold px-4 py-5 border-b border-zinc-700">Web sources</h2><ul></ul></aside><main class="flex-1 p-8 overflow-y-auto">'), Ur = T("<li>"), Hr = T('<h1 class="text-2xl font-bold mb-4 break-all">'), Zr = T('<div class="flex items-center gap-x-2"><div class=loader></div><span class="text-lg font-semibold">Loading...'), Gr = T("<p class=text-zinc-400>Select a web source to view its content."); function Wr() { const [n, e] = S([]), [t, s] = S(null), [r, i] = S(""), [o, l] = S(!1); async function a() { try { const f = await fetch("/api/urls"); if (!f.ok) throw new Error("Failed to fetch sources"); const u = await f.json(); e(u.urls || []), u.urls && u.urls.length > 0 && !t() && c(u.urls[0]) } catch (f) { console.error(f) } } async function c(f) { s(f), l(!0), i(""); try { const u = await fetch(`/api/urls/${encodeURIComponent(f.id)}`); if (!u.ok) throw new Error("Failed to fetch content"); const d = await u.text(); i(d) } catch { i("Error loading content.") } l(!1) } return Ge(() => { a() }), (() => { var f = qr(), u = f.firstChild, d = u.firstChild, p = d.nextSibling, m = u.nextSibling; return E(p, () => n().map(h => (() => { var g = Ur(); return g.$$click = () => c(h), E(g, () => h.url), I(() => Ke(g, `px-4 py-3 border-b border-zinc-700 cursor-pointer hover:bg-zinc-700 transition-colors ${t() && t().id === h.id ? "bg-zinc-700 font-semibold" : ""}`)), g })())), E(m, (() => { var h = x(() => !!t()); return () => h() ? [(() => { var g = Hr(); return E(g, () => t().url), g })(), x(() => x(() => !!o())() ? Zr() : D(Ce, { get content() { return r() } }))] : Gr() })()), f })() } ye(["click"]); var Kr = T('<div class="flex items-center justify-center h-screen"><h1 class="text-2xl font-bold">Redirecting...'); function Qr(n) { const e = cs(); return n.url && e(n.url), e("/assist"), Kr() } const Vr = document.getElementById("root"); jn(() => D(As, { root: Ns, get children() { return [D(Ee, { path: "/assist", component: Ar }), D(Ee, { path: "/notes", component: jr }), D(Ee, { path: "/web-sources", component: Wr }), D(Ee, { path: "*", component: Qr })] } }), Vr);
